<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>通訊P.05 - 資料鏈結層</title>
      <link href="/2021/04/02/%E9%80%9A%E8%A8%8AP.05%20-%20%E8%B3%87%E6%96%99%E9%8F%88%E7%B5%90%E5%B1%A4/"/>
      <url>/2021/04/02/%E9%80%9A%E8%A8%8AP.05%20-%20%E8%B3%87%E6%96%99%E9%8F%88%E7%B5%90%E5%B1%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="資料鏈結層："><a href="#資料鏈結層：" class="headerlink" title="資料鏈結層："></a>資料鏈結層：</h1><p>資料聯結層(Data link layer)這一層是比較特殊的一個階層，因為底下是實體的定義，而上層則是軟體的定義。因此第二層又分兩個子層。偏向硬體的子層稱為MAC，偏向軟體的子層稱為LLC，而這些子層業務分別是產生表頭2和表尾2</p><p>所以資料鏈結層可以分為兩個層，其細分結果如下：<br>OSI 第三層 -&gt; OSI 第二層 的 LLC 層 -&gt; OSI 第二層的 MAC層 -&gt; OSI 第一層</p><h2 id="MAC："><a href="#MAC：" class="headerlink" title="MAC："></a>MAC：</h2><p>該層主要提供兩個業務，尋址機制和通道訪問控制機制，就像是：<br>假設今天你和你哥都用同一台中華電信ADSL，你們的IP就是一樣的，那麼今天老媽在外面要傳送一封信給你，可是你們IP位置一樣，那ADSL是怎麼知道這個封包要傳給你還是你哥，其實很簡單，就是這個封包到你家的ADSL，之後再根據MACAddress去判斷是要給誰(尋址機制要找到的對象)，但因為你和你哥都用同一台ADSL，也就說明外面資料連到ADSL的線只有一條，那麼就必須檢查這個通道是否被正被其他人占用(通道訪問控制機制)，如果該通道正確就傳遞出去(實體層)。</p><h3 id="尋址機制："><a href="#尋址機制：" class="headerlink" title="尋址機制："></a>尋址機制：</h3><p>由上述例子可以知道要找的地址叫做MACAddress，而MACAddress是什麼</p><h4 id="MACAddress："><a href="#MACAddress：" class="headerlink" title="MACAddress："></a>MACAddress：</h4><p>每一台具有連線功能裝置(藍芽、Wifi)的門牌號，每張網卡在出貨時，都自帶全球唯一的MACAddress(門牌號)，意味著理論上整個地球不可能會有重複的MAC地址，其MAC地址透過嚴格控管，才具有該效果，以下範例MAC地址的格式：</p><p>38-BA-F8-12-19-AC</p><p>這是我筆電藍芽的MAC地址，其中</p><ul><li><p>38-BA-F8這是由IEEE控管，必須花錢申請，才能獲得得編號(前24 bit)，而這個編號是廠商 Intel跟IEEE申請的地址</p></li><li><p>12-19-AC這是由生產網卡的廠商自行產生，該廠商必須嚴格紀錄哪些位址被使用了，絕對不能生產出MAC地址重複的地址</p></li></ul><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/7UG6IrH.png" src="/img/loading.gif" class="lazyload" title></a><br>在知道MACAddress的概念後，資料鏈結層的業務會產生表頭2，而表頭2的資訊就是上面的圖片格式。</p><h6 id="雖說不能重複，但其實還是能透過人工修改來重複，也有可能廠商生產紀律很鬆散，但根據OSI-通訊模型可知只要相同MAC網卡裝置，不處在同一個路由器-OSI模型定義的-第三層-網路層-就不會有問題發生。"><a href="#雖說不能重複，但其實還是能透過人工修改來重複，也有可能廠商生產紀律很鬆散，但根據OSI-通訊模型可知只要相同MAC網卡裝置，不處在同一個路由器-OSI模型定義的-第三層-網路層-就不會有問題發生。" class="headerlink" title="雖說不能重複，但其實還是能透過人工修改來重複，也有可能廠商生產紀律很鬆散，但根據OSI 通訊模型可知只要相同MAC網卡裝置，不處在同一個路由器(OSI模型定義的 第三層 網路層)就不會有問題發生。"></a>雖說不能重複，但其實還是能透過人工修改來重複，也有可能廠商生產紀律很鬆散，但根據OSI 通訊模型可知只要相同MAC網卡裝置，不處在同一個路由器(OSI模型定義的 第三層 網路層)就不會有問題發生。</h6><h4 id="WiFi探針："><a href="#WiFi探針：" class="headerlink" title="WiFi探針："></a>WiFi探針：</h4><p>因為MACAddress只用於網卡傳輸，並不屬於隱私裝置，所以有Wifi探針這產品，這是一種能夠蒐集範圍內開啟Wifi功能的裝置，其設備訊息的裝置，其中就有MACAddress和強度，主要用於搜尋範圍內可以連的Wifi有什麼以及強度是什麼，以此來提供連線選擇</p><h4 id="行為監控："><a href="#行為監控：" class="headerlink" title="行為監控："></a>行為監控：</h4><p>但是有心人士利用這缺陷，在商場、百貨公司等等設立這些裝置，每隔幾秒搜尋一次，根據強度來判斷用戶的位置(真實位置，經緯度的那種)，以此來判斷該用戶是不是常客、最喜歡逛哪一區、在哪一區停留最久等等。以此資料為參考，判斷這個MACAddress的用戶，最喜歡哪些商品，逛的是不是高檔區，財力應該很豐富等等，以此進行廣告行銷、詐騙等等都有可能。</p><h4 id="廣告投射和詐騙資料："><a href="#廣告投射和詐騙資料：" class="headerlink" title="廣告投射和詐騙資料："></a>廣告投射和詐騙資料：</h4><p>雖然只能知道MACAddress，不知道這個人的真實信號，但是如果我把這資料整理後販售，APP開發商可以去購買此資料，之後通過APP安裝權限知道你的MACAddress，兩者進行比對，MAC資料告訴我38-BA-F8-12-19-AC經常在高檔內衣區逛，APP資料告訴安裝此APP的用戶是 38-BA-F8-12-19-AC，於是我就可以進行廣告行銷，獲取真實資料，0975-XXX-XXX 黃先生 在某天某地逛高檔內衣區，他很有錢，只在高級內衣區看，之後再把這訊息賣給詐騙集團或是進行廣告投射，詐騙集團就可以謊稱 XXX 請問你是不是在某天某地 購買高檔內衣 之類的詐騙。</p><h4 id="人流監控："><a href="#人流監控：" class="headerlink" title="人流監控："></a>人流監控：</h4><p>當然也可以運用在其他地方，像是這個區域的人都去哪，人數多不多，101煙火是否要進行人流疏導等等之類的，也可以運用特殊地方監控，像是國安地方，某個MACAddress一直在總統府前面徘迴，每天固定時間都來一次，那麼這個人是否有什麼特殊計畫，是要暗殺總統? ，如果在銀行一直徘迴，是要搶劫進行探勘?</p><h4 id="定位輔助："><a href="#定位輔助：" class="headerlink" title="定位輔助："></a>定位輔助：</h4><p>因為開啟WIFI，可以偵測到周圍的WIFI強度，而根據強度可以進行三角定位，就知道你的位置精準到哪，像是UBer，必須依靠非常精準的位置來進行收費，如果位置不精準，收費就不標準。</p><h4 id="資安保護："><a href="#資安保護：" class="headerlink" title="資安保護："></a>資安保護：</h4><p>今天如果要用網路下單，一些金融操作，可以透過MACAddress來加強保障，因為這東西理論上是全球唯一，那麼你常用的電腦應該就只有一台，我就把我MAC地址傳給銀行，每次下單時候銀行都會比對MAC地址，如果不一致可能就是帳密外流，讓別人在異地用其他電腦登入。</p><p>由上述介紹，想必你對MACAddress有更多的了解，那麼我再繼續介紹，要怎麼找到這些MACAddress，位址解析協定(ARP)</p><h4 id="ARP："><a href="#ARP：" class="headerlink" title="ARP："></a>ARP：</h4><p>ARP的功能就是通過解析IP地址得到MAC地址，但是對於他的層級區分是很尷尬的存在，這問題就像是世界上最好的程式語言是什麼? <del>PHP</del><br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/mqgDFJd.png" src="/img/loading.gif" class="lazyload" title></a><br>哎呀，放錯張圖了，下面這張才是，上圖是PHP官方某次更新文檔的說明<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/6kkXWff.png" src="/img/loading.gif" class="lazyload" title></a></p><p>如果使用暴力區分：<br>不知道MAC為實體層<br>知道MAC為資料鏈結層<br>知道IP為網路層</p><p>那麼ARP就屬於網路層，但是ARP功能是獲取到MACAddress，所以功能性應該屬於資料鏈結層，顧此處以資料鏈結層為標準。 <del>反正IPv4才用ARP，現在IP也快用完了，IPv6不使用ARP，管他去死</del></p><p>ARP為了實現IP地址與MAC地址的查詢與轉換，ARP協議引入了ARP緩存表的概念，每台主機或路由器在維護著一個ARP緩存表（ARP table），這個表包含IP地址到MAC地址的映射關係，如下<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/TzvBFHs.png" src="/img/loading.gif" class="lazyload" title></a><br>通常每個Items都會有自己的壽命，默認是10分鐘，就是10分鐘刷新一次的意思</p><p>假設今天</p><p>主機A的IP地址為192.168.1.1，MAC地址為0A-11-22-33-44-01；<br>主機B的IP地址為192.168.1.2，MAC地址為0A-11-22-33-44-02；</p><ol><li>A根據自己的ARP表查詢是否有匹配B的IP</li><li>如果沒有，A就會發送ARP請求(目標MAC地址為FF-FF-FF-FF-FF-FF)到該WIFI內的所有主機，其格式如下：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/UuEXffW.png" src="/img/loading.gif" class="lazyload" title></a></li><li>每個主機都會檢查，這個ARP請求裡面的IP是不是再說我?而B主機發現請求的IP就是在說我，於是B主機就會把自己的MAC地址和IP填寫好成一個新的ARP表</li><li>B將填寫好的ARP表，在發送回去給A</li><li>當A拿到新的ARP表，則可以利用上面的資訊進行溝通</li></ol><h4 id="ARP攻擊："><a href="#ARP攻擊：" class="headerlink" title="ARP攻擊："></a>ARP攻擊：</h4><p>因為ARP的缺陷，在接收其他電腦的ARP表時候，不會檢查正確就直接引用，所以如果今天我創立一個假的ARP表，192.168.1.1 的MAC地址被我竄改，然後把這個ARP表廣播給同WIFI全部主機，大家都會接受，於是當有人要傳給192.168.1.1時候因為表裡面已經存在了，所以那個人就拿到MAC地址，也不用再發廣播誰是192.168.1.1，之後透過我造假的MAC地址傳送資料，於是就導致192.168.1.1的真實主機拿不到資料，而他的資料全部傳到一個假的MAC地址，那麼如果我很討厭192.168.1.50，我就先獲取他的正確MAC地址，把所有人的MAC地址都改成IP 50的MAC地址，於是一下子，30幾台電腦的資料都塞爆他，同時30幾台的資料都不會正確接收。</p><h3 id="通道訪問控制："><a href="#通道訪問控制：" class="headerlink" title="通道訪問控制："></a>通道訪問控制：</h3><p>上述講了同一個WIFI內要如何尋找到正確的MAC位址，那麼我們來談，因為同一個WIFI，並且該WIFI是非全雙工的形式，所以通道只有一個，同一時間只能一人使用，那麼我要如何有效、公平的使用，可能有人會回答多工，確實，多工是其中一種解決方案，但是因為多工實施起來成本高、複雜高，那就沒必要使用多工技術，所以多工只運用在大項目，像是實體層 Wifi要怎麼傳輸，很明顯這關連到整個使用WIFI的人(因為頻譜無法重複利用)，也就是全世界的人，所以才需要多工，反而是都在同一個區域網路內，因為有時候只有你一個人在家，有時候兩個人在家，再少人時候，多工反而更拖累效能，故我們使用Access control策略，而不是多工策略，其中最出名的方案為CSMA系列</p><p>今天如果不使用多工，那麼就代表一個人占用共用通道，因為區域網路不是每個時候都必須共用，但也因此，如果你佔用了頻道，別人此時要使用，就會發生”碰撞”，發生碰撞後應該等待占用的人使用完畢再換你使用，就像廁所一樣，並且發生了碰撞會影響到傳送速度，所以使用一些協定來降低碰撞的發生，並且可以適時的利用頻譜通道，像是CSMA/CD、CSMA/CS。</p><h4 id="碰撞："><a href="#碰撞：" class="headerlink" title="碰撞："></a>碰撞：</h4><p>搶廁所就是一種碰撞，當A在廁所，其他人直接打開廁所門發現A在裡面(碰撞)，於是A就必須重新醞釀情緒，就拉長上廁所的時間(碰撞後的影響)，那麼我們知道碰撞的概念了，接下來我們要細分碰撞的Case，這樣我們才能設計出降低碰撞發生的方法。</p><ol><li>A先到家並上廁所，後來B到家，打開廁所門發現A在裡面，此時就發生了碰撞</li><li>A和B同時到家，A和B同時想上廁所，此時就發生了碰撞</li></ol><p>針對第1點，科學家們使用CSMA技術來解決，第2點使用CD技術來解決</p><h4 id="載波偵測多重存取-CSMA-："><a href="#載波偵測多重存取-CSMA-：" class="headerlink" title="載波偵測多重存取(CSMA)："></a>載波偵測多重存取(CSMA)：</h4><p>載波偵測(Carrier Sense，CS)：是指資料傳送之前必須先偵測傳輸通道是否有其他主機在使用，如果無人使用，則立刻傳送資料；如果有人使用，則等候一段「隨機時間」之後再傳送資料，簡單說就是會先敲廁所門。以此來達到多重存取(Multiple Access，MA)。</p><h4 id="碰撞偵測-CD-："><a href="#碰撞偵測-CD-：" class="headerlink" title="碰撞偵測(CD)："></a>碰撞偵測(CD)：</h4><p>其實A和B同時發生碰撞，是無法避免的，我們只能設計出發生這問題時該如何善後，以此降低第二次碰撞的發生，當發生A和B同時碰撞時候，此時根據發生碰撞的位置，如果位置距離A比較近，A就發出一個壅塞訊號(Jam Signal)，通知所有電腦現在發生碰撞拉，請大家暫緩傳送一下，並且把A和B的請求蓋掉，告訴A和B：你們剛剛發的請求，我當作沒聽到，你們再等待N秒後在進行傳送一次，此時就要有個演算法(Binary Exponential Backoff Algorithm)，來告訴A你要等1秒，B你等0.5秒，這樣就不會發生碰撞了。使用該技術最出名的：乙太網路系統，也就是有線網路。</p><h4 id="碰撞避免-CA-："><a href="#碰撞避免-CA-：" class="headerlink" title="碰撞避免(CA)："></a>碰撞避免(CA)：</h4><p>對於具有實體介質(網路線)的網路可以偵測訊號碰撞，但是沒有實體介質的無線網路要偵測訊號碰撞極為困難，因此科學家發明了「碰撞避免(CA：Collision Avoidance)」來取代「碰撞偵測(CD：Collision Detection)」，此種方案採用主動避免碰撞而非被動偵測的方式來解決碰撞問題。可以滿足那些不易準確偵測是否有碰撞發生的需求。</p><p>假設A和B要同時傳送封包</p><ol><li>A產生隨機的延遲時間為DT_A(假設0.1秒)，B也產生隨機的延遲時間為DT_B(假設0.2秒)</li><li>A在DT_A時間內發現頻道忙碌的話，就會停止倒數計時DT_A，直到確定通道是空的才會繼續計時</li><li>當DT_A時間到了，A會發出RTS訊號，此時通道被RTS塞滿，DT_B就會停止倒數</li><li>當WIFI AP接收到RTS訊號，就會回應CTS訊號回去，此時通道又被CTS塞滿，DT_B又會停止倒數</li><li>當A收到CTS訊號，就會把資料傳送出去，通道又被A佔據，DT_B又會停止倒數</li><li>當DT_B時間到了，B就會延續上面的步驟。<br>上述仍會發生A和B因為同時時間到了，導致通道內會有多個RTS或CTS等等資料進行碰撞，但是這是請求封包的碰撞，這個請求往往都比資料小上好多倍，碰撞也不會讓資料本體造成干擾，所以讓傳送變得更可靠。</li></ol><h2 id="LLC-Logical-Link-Control-："><a href="#LLC-Logical-Link-Control-：" class="headerlink" title="LLC(Logical Link Control)："></a>LLC(Logical Link Control)：</h2><p>上述主要講說，LLC是偏向軟體方面，讓較高層次的通訊軟體使用，使得那些較高層次的通訊軟體只要透過 LLC 層就可以存取網路，而不用去考慮所連接的網路型態。也就是說你可以把它當作工具人，這個工具人負責叫LLC負責幫你存取網路。</p><h3 id="LLC的多工"><a href="#LLC的多工" class="headerlink" title="LLC的多工"></a>LLC的多工</h3><p>LLC 提供若干個『邏輯鏈路』(Logical Link)，讓多個應用程式同時使用。假設今天A工作站有很多隻程式，而每個程式都跟不同的工作站通訊：<br>A 的 P1 -&gt; B 的 P4<br>A 的 P2 -&gt; C 的 P5<br>A 的 P3 -&gt; D 的 P6<br>由上面情況可知，A的工作站一次開啟多個程式，但是每個程式都要占用網卡的通道，來傳達資料，那麼LLC是必要提供所謂的多工服務。</p><p>想想今天某個人，一次寫5封要送信給A，但是A在美國，那麼作為郵局的我們，勢必要派出5個郵差去接洽，讓每一封信都順利的到國際信封中心進行轉交給美國的A，<br>而國際信封中心只有一間，而且它們入口很窄，一次只能讓一個人送，並且不是只有台灣有在用，世界上上百個國家都要送到這個國際中心，於是國際信封中心訂了個規則，一個人有10秒的時間，10秒到了就從國際中心的出口出來，再換下一個人(同理，台灣 -&gt; 國際信封中心 這個流程也是相同於 國際信封中心 -&gt; 美國)。</p><p>5個封信就是5個程式，每個程式都會有對應的郵差窗口，就叫做『服務存取點』（Service Access Point, SAP），一個人10秒時間，就是TDMA多工來實作，但是實際情況還是依靠作業系統決定，作業系統就是國際信封中心。</p><h3 id="LLC的封包協議："><a href="#LLC的封包協議：" class="headerlink" title="LLC的封包協議："></a>LLC的封包協議：</h3><p>上述送信遊戲可以知道，LLC的扮演角色是什麼，而信封都有固定的格式，這樣才能知道你誰，要寄到哪邊去，LLC同樣也有固定的格式，LLC-PDU可以當作信封的意思。</p><ol><li>『目的地服務存取點點』（Destination Service Access Point, DSAP）：DSAP是為了能夠辨認出LLC通訊協定間傳送的資料到底是屬於誰的，在DSAP欄位標明對方工作站的服務存取點，也表示銜接到對方通訊應用程式。</li><li>『原始服務存取點點』（Source Service Access Point, SSAP）：傳送端LLC的服務存取點，亦表示連接傳送端本身的應用程式。</li><li>控制欄：告訴對方本 LLC-PDU的意義，是傳送資料(由上層傳送下來)，或是雙方的控制訊息，控制欄主要作為雙方協議溝通使用。</li><li>訊息欄：如果由控制欄位知道該封包做為傳送資料之用，則訊息欄是負責接受上層（或網路層）的資料，再包裝成LLC-PDU。如果控制欄表示本封包是作為連線交談用，則訊息欄是作為交談訊息存放用，對方由訊息欄可知道溝通的內容。</li></ol><p>有了上述這些功能後，就可以順利的把MAC表頭2包在封包內送給實體層來實作，但是理想上這些資料是不會產生問題的，但是萬一受到雜訊干擾的話，那資料傳送就失敗了，也因為實體層不需要加入表頭，這一層是最後一層，所以在最後一層這邊，資料鏈結層還會進行一些偵錯處理，把一些偵錯的處理放在最後面，也就是表尾2的內容。</p><h3 id="循環冗餘檢查碼-CRC-："><a href="#循環冗餘檢查碼-CRC-：" class="headerlink" title="循環冗餘檢查碼(CRC)："></a>循環冗餘檢查碼(CRC)：</h3><p>還記得之前在說數位和類比的差別嗎，為什麼1G通話是使用類比，2G就廢棄改用數位嗎，其原因是數位有太多好處，可以進行偵錯、除錯、加密、壓縮等等，而CRC就是用於除錯的。</p><p>假設今天我要傳送資料叫做 10001，那們CRC進行加法運算，1+0+0+0+1 = 2，並將2轉成2進制為10，之後把10塞到表尾。</p><p>當接收端拿到資料後，會把先讀取表尾，表尾告訴我CRC結果是10，那我去解析資料，資料因為雜訊干擾，變成10000，我自己計算出該筆資料CRC結果是1，但是傳送端的CRC結果告訴我應該是要10而不是1，所以我可以斷定這資料是有誤的，這就是一種偵錯方式。</p><p>當然如果是 10001 被干擾成 10100，這樣加起來還是10，於是判定為通過CRC偵錯，但是結果很明顯是錯誤的，所以CRC檢查不會用加法這種簡單數學演算法，而是用更複雜的多項式，並且也僅支援錯一部分的偵錯。</p><h6 id="數學的偵錯有很多種，像是台灣身分證，A123456789，A代表台北市，1代表男生，於是數學家們將12345678這些數字套入，台灣身分證產生公式，可以得出-121-這個數字，之後除以10餘1，因此10-1-9，所以A12345678這個檢查碼應該是9，所以這是一個合法的身分證字號。"><a href="#數學的偵錯有很多種，像是台灣身分證，A123456789，A代表台北市，1代表男生，於是數學家們將12345678這些數字套入，台灣身分證產生公式，可以得出-121-這個數字，之後除以10餘1，因此10-1-9，所以A12345678這個檢查碼應該是9，所以這是一個合法的身分證字號。" class="headerlink" title="數學的偵錯有很多種，像是台灣身分證，A123456789，A代表台北市，1代表男生，於是數學家們將12345678這些數字套入，台灣身分證產生公式，可以得出 121 這個數字，之後除以10餘1，因此10-1 = 9，所以A12345678這個檢查碼應該是9，所以這是一個合法的身分證字號。"></a>數學的偵錯有很多種，像是台灣身分證，A123456789，A代表台北市，1代表男生，於是數學家們將12345678這些數字套入，台灣身分證產生公式，可以得出 121 這個數字，之後除以10餘1，因此10-1 = 9，所以A12345678這個檢查碼應該是9，所以這是一個合法的身分證字號。</h6><h6 id="A123456789-是符合台灣身分證字號的規則，該身分證是台北內湖謝條根先生，他因為身分證太簡單，經常被冒用，經常上法院，涉及援交、台鐵訂票、公司逃漏稅、健保看病、詐騙集團申請信用卡、網拍帳號等。"><a href="#A123456789-是符合台灣身分證字號的規則，該身分證是台北內湖謝條根先生，他因為身分證太簡單，經常被冒用，經常上法院，涉及援交、台鐵訂票、公司逃漏稅、健保看病、詐騙集團申請信用卡、網拍帳號等。" class="headerlink" title="A123456789 是符合台灣身分證字號的規則，該身分證是台北內湖謝條根先生，他因為身分證太簡單，經常被冒用，經常上法院，涉及援交、台鐵訂票、公司逃漏稅、健保看病、詐騙集團申請信用卡、網拍帳號等。"></a>A123456789 是符合台灣身分證字號的規則，該身分證是台北內湖謝條根先生，他因為身分證太簡單，經常被冒用，經常上法院，涉及援交、台鐵訂票、公司逃漏稅、健保看病、詐騙集團申請信用卡、網拍帳號等。</h6>]]></content>
      
      
      <categories>
          
          <category> 通訊協定系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
            <tag> 協定 </tag>
            
            <tag> OSI </tag>
            
            <tag> TCP/IP協定 </tag>
            
            <tag> 資料鏈結層 </tag>
            
            <tag> LLC </tag>
            
            <tag> MAC </tag>
            
            <tag> MACAddress </tag>
            
            <tag> WiFi探針 </tag>
            
            <tag> 行為監控 </tag>
            
            <tag> 廣告投射 </tag>
            
            <tag> 詐騙資料 </tag>
            
            <tag> 人流監控 </tag>
            
            <tag> 定位輔助 </tag>
            
            <tag> 資安保護 </tag>
            
            <tag> ARP </tag>
            
            <tag> ARP緩存表 </tag>
            
            <tag> ARP攻擊 </tag>
            
            <tag> 通道訪問控制 </tag>
            
            <tag> CSMA/CD </tag>
            
            <tag> CSMA/CS </tag>
            
            <tag> DSAP </tag>
            
            <tag> SSAP </tag>
            
            <tag> CRC </tag>
            
            <tag> 身分證 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通訊P.03 - 實體層、介質</title>
      <link href="/2021/04/02/%E9%80%9A%E8%A8%8AP.03%20-%20%E5%AF%A6%E9%AB%94%E5%B1%A4%E3%80%81%E4%BB%8B%E8%B3%AA/"/>
      <url>/2021/04/02/%E9%80%9A%E8%A8%8AP.03%20-%20%E5%AF%A6%E9%AB%94%E5%B1%A4%E3%80%81%E4%BB%8B%E8%B3%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="實體層："><a href="#實體層：" class="headerlink" title="實體層："></a>實體層：</h1><p>電腦之間要傳輸訊息，必須透過實體連線（無論有線或無線傳輸）的銜接，將資料轉換成訊號傳遞給對方。而其牽涉到使用的傳輸介質、傳輸類型、傳送技術等等。</p><p>Ex:今天你用嘴巴說出”Lucas”，之後聲波傳遞到別人的耳廓，你的嘴巴就是發送端的實體層，聲波就是介質，別人的耳廓就是接收端的實體層。</p><h2 id="傳輸介質："><a href="#傳輸介質：" class="headerlink" title="傳輸介質："></a>傳輸介質：</h2><p>今天要傳送一個封包，那這個封包要麼傳?用無線還是有線通訊，那麼對應的設備、介質是什麼？</p><h3 id="雙絞銅線："><a href="#雙絞銅線：" class="headerlink" title="雙絞銅線："></a>雙絞銅線：</h3><p>有線通訊的一種介質，將兩根絕緣銅導線按一定規格互相旋轉絞在一起(能有效降低射頻干擾-RFI)，使用電流傳導來傳遞訊號，容易受電磁波干擾。為了解決問題，於是有了遮蔽式雙絞線(STP)和無遮蔽式雙絞線(UTP)</p><ol><li>STP：因有銅網或銅箔環繞保護干擾低，但是不容易佈線並且比較貴。</li><li>UTP：費用便宜也容易佈線，因此常用於RJ45接頭的傳輸介質，是目前乙太網路最常用的線材。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/71vwItt.png" src="/img/loading.gif" class="lazyload" title></a><h3 id="同軸電纜："><a href="#同軸電纜：" class="headerlink" title="同軸電纜："></a>同軸電纜：</h3>有線通訊的一種介質，由一根銅線製成內導線傳遞訊號，先包覆一層絕緣體，外面再包覆網狀導體防止電磁波散射，並且具備接地功能防止雜訊干擾，最後再包覆絕緣材料(塑膠皮)，使用電波傳導來傳遞訊號，由於使用電波來傳遞，在網路上任何一點都可利用感應讀取或傳送訊息，因此較適合廣播網路，其使用場合可根據阻抗分為2種。</li><li>50歐姆：是早期乙太網路使用的介質，但是後來被RJ45接頭的雙絞線取代</li><li>75歐姆：用於有線電視(CATV)和機上盒等裝置。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/0mAh0KU.png" src="/img/loading.gif" class="lazyload" title></a><h3 id="光纖："><a href="#光纖：" class="headerlink" title="光纖："></a>光纖：</h3>有線通訊的一種介質，為目前骨幹網路()的主要傳輸媒介，不但有較高的承載量，而且可傳輸較遠的距離。其所傳遞的是光的訊號，因此必須有光源，可怖至於惡劣環境當中。常見的光源有兩種：發光二極體（LED）和雷射二極體（Laser），以此可分為：</li><li>發光二極體（LED）的光源發射器和接收器較為便宜，大都配合多模（Multi-mode）光纖使用，價錢較便宜，傳輸距離也較近，大約在 1000 公尺以內。</li><li>雷射二極體（Laser Diode）的光源發射器和接收器較昂貴，一般都配合單模（Single–mode）光纖使用，傳輸距離可達數十公里。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/UThK5jf.png" src="/img/loading.gif" class="lazyload" title></a></li></ol><h3 id="有線通訊的介質選擇："><a href="#有線通訊的介質選擇：" class="headerlink" title="有線通訊的介質選擇："></a>有線通訊的介質選擇：</h3><p>1) 資料傳輸量：對於傳輸量較高且距離較遠的傳輸骨幹（Backbone），則會使用光纖纜線或同軸電纜，至於使用者端或近距離的傳輸，則使用雙絞線（Cat-5 UTP或STP）。<br>2) 可靠度：網路可靠度高，表示訊號在傳送當中不容易受到外來雜訊干擾，或纜線之間所產生的『串音』。所以對於傳輸品質要求較高的傳輸線，不妨考慮使用光纖。<br>3) 鋪設環境：一般在室外佈放光纖纜線較理想，室內可考慮其他纜線。對於環境較惡劣的環境也必須使用光纖。</p><h3 id="電磁波："><a href="#電磁波：" class="headerlink" title="電磁波："></a>電磁波：</h3><p>而無線通訊採用電磁波，這邊先解釋電磁波是什麼東西，首先在很久以前，電和磁分別是兩種完全不同的現象，就像狗和貓一樣，是完全不一樣的東西，丹麥科學家厄斯特發現電流可以產生磁場，磁場是一種能量具有N極和S極，就像是磁鐵，法拉第發現磁場可以產生電場，電場也是一種能量正電和負電，是把這兩者的現象重新理解一次的人，特斯拉發現交流電，馬克士威發現了</p><ol><li>變化磁場 產生 變化電場</li><li>變化電場 產生 變化磁場<br>那麼如果我使用交流電，交流電的電壓是變化的，於是產生了變化電場，接續又產生變化磁場 … ，電磁波就是在電場和磁場交互作用產生的能量，而此能量在空間中以波的行式存在，就稱為電磁波，由此可以得出電磁波是不需要介質的，像是光，光也是一種電磁波的一種也不需要介質。<br>聲波就需要介質了，為什麼你的耳朵能聽到聲音，是因為聲音的產生，是因為物體振動的關係，像是我們喉嚨產生震動、音叉產生震動，而物體震動會產生一種波，我們稱為聲波，聲波具有能量，以音叉為例，敲打音叉，音叉產生震動，震動的音叉推開周圍的空氣，空氣的變化一直傳遞到你的耳朵，由此你就能聽到聲音，而空氣就是聲音的介質，所以在太空中，沒有空氣的存在，太空人必須透過對講機說話，對講機根據太空服內的氧氣作為介質，以此接收聲波，之後透過無線傳輸到另一個太空人的對講機，來實現傳達聲音的功能。</li></ol><p>經過上述說明，了解到電磁波是什麼，為什麼電磁波不需要介質，既然電磁波不需要介質，那麼無線通訊都是使用電磁波這物理現象，嚴格來說並不存在介質。</p><h2 id="接頭："><a href="#接頭：" class="headerlink" title="接頭："></a>接頭：</h2><p>上面介紹了介質有很多種介質，那麼特殊介質必定要搭配特殊接頭，才能將資料傳送到機器內，就像是不同的電線有不同的接頭，微波爐、電腦電源等等高用電的電線很粗，並且接頭是三個插座，所以此處介紹接頭：</p><h3 id="RJ45："><a href="#RJ45：" class="headerlink" title="RJ45："></a>RJ45：</h3><p>這是最常用的雙絞線網路線插頭，根據上述介質選擇，我們可以知道今天如果要從中華電信的數據機連線到你的主機，那麼雙絞線是你最好的選擇，於是就有了RJ45這個用於雙絞線的接頭，該接頭總共需要有8條纜線接到插頭，而插頭上8個纜線插槽上都有各自的定義：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/mCEu7IP.png" src="/img/loading.gif" class="lazyload" title></a><br>只要將4對雙絞線按照一定的順序，將導線插入指定的插槽，之後固定插槽，一條網路線就完成了。</p><p>而無線通訊部分，科學家發現，電磁波以波的形式存在，而其波的頻率，一但被使用就無法共用，由此可知頻譜的珍貴，為了解決僧多粥少的難題，工程師研發出許多技術，來擴增頻譜的使用率，所以有了一些設備來實現這些優化技術，所以此處介紹，數位訊號傳輸會用到的IC：基頻晶片(BP)、中頻晶片(IF)、射頻晶片（RF)。</p><p>下圖是我們使用要把聲音傳遞到會使用的流程，由此圖可以得IC的層級順序<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/TTdeA93.png" src="/img/loading.gif" class="lazyload" title></a><br>聲波由麥克風接收後為低頻類比訊號，之後再經過轉換(ADC，請參考音檔的誕生篇)成數位訊號。</p><h3 id="基頻-BB-："><a href="#基頻-BB-：" class="headerlink" title="基頻(BB)："></a>基頻(BB)：</h3><p>「基頻晶片（BB）」進行 資料壓縮／解壓縮、頻道編碼／解碼、交錯置／解交錯置、加密／解密、格式化／解格式化、多工／解多工、調變／解調 …等數位訊號處理。</p><h3 id="中頻-IF-："><a href="#中頻-IF-：" class="headerlink" title="中頻(IF)："></a>中頻(IF)：</h3><p>由於無線通訊用的電磁波頻率很高，直接把數位轉成GHz頻率或是把GHz頻率轉成數位，在早期會有困難，於是經由「中頻晶片（IF）」，轉換為中頻類比訊號，但是現在科技進步，直接將數位轉成GHz等級的類比頻率變得容易了以及把GHz頻率直接轉換為數位更容易，於是達到「零中頻(ZIF：Zero IF)」的目標</p><h3 id="射頻-RF-："><a href="#射頻-RF-：" class="headerlink" title="射頻(RF)："></a>射頻(RF)：</h3><p>處理高頻率的電磁波，用於發送/接收 高頻率的電磁波，根據調變的結果，形成不同時間、頻率、波形的電磁波由天線傳送/接收進來出去。</p>]]></content>
      
      
      <categories>
          
          <category> 通訊協定系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
            <tag> 協定 </tag>
            
            <tag> 無線通訊 </tag>
            
            <tag> 有線通訊 </tag>
            
            <tag> OSI </tag>
            
            <tag> 實體層 </tag>
            
            <tag> TCP/IP協定 </tag>
            
            <tag> 介質 </tag>
            
            <tag> 雙絞銅線 </tag>
            
            <tag> STP </tag>
            
            <tag> UTP </tag>
            
            <tag> 同軸電纜 </tag>
            
            <tag> 電視 </tag>
            
            <tag> 光纖 </tag>
            
            <tag> 電磁波 </tag>
            
            <tag> 厄斯特 </tag>
            
            <tag> 磁場 </tag>
            
            <tag> 電場 </tag>
            
            <tag> 法拉第 </tag>
            
            <tag> 特斯拉 </tag>
            
            <tag> 交流電 </tag>
            
            <tag> 馬克士威 </tag>
            
            <tag> 聲波 </tag>
            
            <tag> 可見光 </tag>
            
            <tag> RJ45 </tag>
            
            <tag> 基頻 </tag>
            
            <tag> 中頻 </tag>
            
            <tag> 射頻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通訊P.04 - 實體層、傳輸技術</title>
      <link href="/2021/04/02/%E9%80%9A%E8%A8%8AP.04%20-%20%E5%AF%A6%E9%AB%94%E5%B1%A4%E3%80%81%E5%82%B3%E8%BC%B8%E6%8A%80%E8%A1%93/"/>
      <url>/2021/04/02/%E9%80%9A%E8%A8%8AP.04%20-%20%E5%AF%A6%E9%AB%94%E5%B1%A4%E3%80%81%E5%82%B3%E8%BC%B8%E6%8A%80%E8%A1%93/</url>
      
        <content type="html"><![CDATA[<h1 id="資料傳輸："><a href="#資料傳輸：" class="headerlink" title="資料傳輸："></a>資料傳輸：</h1><p>在上一章我們提到了無論是有線還是無線，工程師研發了很多技術，來讓使用效率、可靠性、公平性等等來提高，那麼在這些複雜技術的背後，就是基於三個基本概念，調變、多工、雙工。</p><h2 id="調變："><a href="#調變：" class="headerlink" title="調變："></a>調變：</h2><p>發送端將原始資料混入高頻率的波，透過高頻率的波傳送出去，被稱為「調變(Modulation)」，而高頻率的波最容易產生的方式就是電磁波，所以以下調變技術的高頻率的波都是在說電磁波。</p><h3 id="解調："><a href="#解調：" class="headerlink" title="解調："></a>解調：</h3><p>接收端將接收的高頻率的波，取出其中的原始資料稱為「解調(Demodulation)」。</p><h3 id="多工："><a href="#多工：" class="headerlink" title="多工："></a>多工：</h3><p>多人共同使用一條資訊通道的方法，就像是家裡的WIFI AP，你也連線，你爸也連線，你哥也連線，請問只有一條資訊通道要怎麼同時給這麼多人用，多工就是為了解決這問題，主要負責讓這條通道更有效率的使用並且更公平的分配。</p><p>那麼我們今天來討論如何實現這些技術，首先根據介質主要分為有線和無線，而資料也可以區分為類比(麥克風、溫度)和數位(文字、數字)，故總共會有4種搭配，其每種搭配都有其數據傳輸的技術：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/vCA3z0z.png" src="/img/loading.gif" class="lazyload" title></a></p><h3 id="➤類比訊號-gt-類比傳輸："><a href="#➤類比訊號-gt-類比傳輸：" class="headerlink" title="➤類比訊號-&gt;類比傳輸："></a>➤類比訊號-&gt;類比傳輸：</h3><p>科學家發現低頻率的波無法傳遞得很遠，很容易被干擾，於是研發了振幅調變(AM)、頻率調變(FM)、相位調變(PM)等三種，都是屬於「高頻載波技術」，就是把一個低頻率的波用高頻率的波裝載他，就像是人的跑速很慢，要提高速度就去做高鐵，高鐵就是高頻率的波，人就是被裝載的低頻率的波，AM、FM、PM 就是木箱、鐵箱、紙箱，分別有不同的裝載方式，其中現實世界中使用這些最出名的產品有：傳統電話、傳統收音機、傳統無線電視、無線對講機、黑金剛(第一代手機)。</p><h4 id="AM："><a href="#AM：" class="headerlink" title="AM："></a>AM：</h4><p>使用電磁波依照「振幅大小」載著低頻訊號傳送出去。聲音大的時候「振幅大」，聲音小的時候「振幅小」。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/a4Z0Fm4.png" src="/img/loading.gif" class="lazyload" title></a></p><h4 id="FM："><a href="#FM：" class="headerlink" title="FM："></a>FM：</h4><p>使用電磁波依照「頻率高低」載著低頻訊號傳送出去。聲音大的時候「頻率高」，聲音小的時候「頻率低」。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/jaQpo67.png" src="/img/loading.gif" class="lazyload" title></a></p><h4 id="PM："><a href="#PM：" class="headerlink" title="PM："></a>PM：</h4><p>使用電磁波依照「相位不同(波形不同)」載著低頻訊號傳送出去。聲音大的時候「相位270度」，聲音小的時候「相位0度」。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/rtwP6Bj.jpg" src="/img/loading.gif" class="lazyload" title></a></p><p>以上是類比通訊(類比訊號-&gt;類比傳輸)的實作方法，但不論哪種方法，都會產生以下問題<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/Q8YucMy.png" src="/img/loading.gif" class="lazyload" title></a><br>如果今天傳送過程中有雜訊，那麼雜訊就會干擾到原低頻訊號，就像是小時候下雨天收音機會有嘶嘶嘶嘶嘶嘶的聲音、電視會有嘶嘶嘶嘶和雪花的問題，這些都是雜訊干擾的結果，類比通訊無法消除雜訊，於是為了改進該問題，就有了數位訊號-&gt;類比傳輸</p><h3 id="➤數位訊號-gt-類比傳輸："><a href="#➤數位訊號-gt-類比傳輸：" class="headerlink" title="➤數位訊號-&gt;類比傳輸："></a>➤數位訊號-&gt;類比傳輸：</h3><p>為了解決類比通訊的缺點：無法加密、無法剔除雜訊等等問題，於是改用數位訊號進行類比傳輸，將「數位訊號(0與1)」混入「高頻的載波」稱為「數位訊號調變技術」，常見的方法包括：振幅位移鍵送(ASK)、頻率位移鍵送(FSK)、相位位移鍵送(PSK)、變形的PSK、正交振幅調變(QAM)，這些是目前甚至未來通訊的主角，包括過去的第二代(2G)、第三代(3G)行動電話，現在的第四代(4G)行動電話，甚至未來的第五代(5G)行動電話都是使用這種技術</p><h4 id="ASK："><a href="#ASK：" class="headerlink" title="ASK："></a>ASK：</h4><p>使用電磁波依照「振幅大小」載著數位訊號傳送出去。1的時候「振幅大」，0的時候「振幅小」。</p><h4 id="FSK："><a href="#FSK：" class="headerlink" title="FSK："></a>FSK：</h4><p>使用電磁波依照「頻率高低」載著數位訊號傳送出去。1的時候「頻率高」，0的時候「頻率低」。</p><h4 id="PSK："><a href="#PSK：" class="headerlink" title="PSK："></a>PSK：</h4><p>使用電磁波依照「相位不同(波形不同)」載著數位訊號傳送出去。具體什麼相位代表0，什麼相位代表1，請參考變形PSK。</p><p>以上的傳輸方式，PSK是最優秀的，抗雜訊能力最好，因此最常被使用。</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/oG1Hdi4.png" src="/img/loading.gif" class="lazyload" title></a></p><h4 id="變形的PSK-BPSK："><a href="#變形的PSK-BPSK：" class="headerlink" title="變形的PSK - BPSK："></a>變形的PSK - BPSK：</h4><p>PSK使用相位0度(先上後下的波形)代表0，項位180度(先下後上的波形)代表1，則稱為BPSK，上面的PSK範例圖，就是採用BPSK，其抗雜訊能力很高，並且在工程設備實施會比較簡單。</p><h4 id="變形的PSK-QPSK："><a href="#變形的PSK-QPSK：" class="headerlink" title="變形的PSK - QPSK："></a>變形的PSK - QPSK：</h4><p>根據上面的BPSK分法，0度 = 0，180度 = 1，那麼我們為何不分得更仔細</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/E1flGZq.png" src="/img/loading.gif" class="lazyload" title></a></p><p>這就叫做四相位位移鍵送(QPSK)，這樣做的好處就是，傳輸量會增加，如果今天是同一長度的波，BPSK只能傳輸1和0，但是QPSK能傳輸00、01、10、11</p><p>如果今天我有份資料，用BPSK估計要傳2秒，但是QPSK就只用1秒，因為QPSK攜帶的資訊比BPSK多，但是因為抗雜訊能里不如BPSK，因為誤差允許範圍由180變成90，直接砍半，並且工程設備實施會比較複雜，但以現在半導體製程，也不會太複雜</p><h4 id="變形的PSK-16PSK："><a href="#變形的PSK-16PSK：" class="headerlink" title="變形的PSK - 16PSK："></a>變形的PSK - 16PSK：</h4><p>既然能把項位分割成4份，那麼為何我們不可以分割成16份，這樣一次就攜帶更多的資料，此技術就叫做16PSK</p><h4 id="變形的PSK-64PSK："><a href="#變形的PSK-64PSK：" class="headerlink" title="變形的PSK - 64PSK："></a>變形的PSK - 64PSK：</h4><p>既然能把項位分割成16份，那麼為何我們不可以分割成64份，這樣一次就攜帶更多的資料，此技術就叫做64PSK</p><p>根據上面的變形PSK可以知道，理論上應該可以分割出無限多個PSK，那麼傳輸速度不就超級快嗎，其實不然，因為今天你要手機要產生這些相位波形，那麼射頻元件(發送訊號的元件)，就必須非常精準的切割出來，並且接收端收到後，要能夠區分相位角度得出代表的數位資訊，如果360PSK，接收端要區分167度和168度，這是非常困難的，需要非常精準的接收IC元件，並且要能夠區分雜訊，所以精度越高就代表越貴越難製作。</p><h4 id="QAM："><a href="#QAM：" class="headerlink" title="QAM："></a>QAM：</h4><p>同時利用電磁波的「振幅大小」與「相位不同（波形不同）」載著數位訊號（0 與 1）傳送出去，就是混血兒，PSK和ASK的混合體，其變形運用就像PSK命名一樣，其參考圖如下。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/4GMxQcO.png" src="/img/loading.gif" class="lazyload" title></a></p><h6 id="所謂的手機通訊世代：1G、2G、3G、4G、5G等等，就是採用不同的傳輸方案，其中4G採用64-QAM或256-QAM，5G採用512-QAM或1024-QAM。"><a href="#所謂的手機通訊世代：1G、2G、3G、4G、5G等等，就是採用不同的傳輸方案，其中4G採用64-QAM或256-QAM，5G採用512-QAM或1024-QAM。" class="headerlink" title="所謂的手機通訊世代：1G、2G、3G、4G、5G等等，就是採用不同的傳輸方案，其中4G採用64-QAM或256-QAM，5G採用512-QAM或1024-QAM。"></a>所謂的手機通訊世代：1G、2G、3G、4G、5G等等，就是採用不同的傳輸方案，其中4G採用64-QAM或256-QAM，5G採用512-QAM或1024-QAM。</h6><p>以上就是數位訊號用類比傳輸的調變方案，而傳輸操作使用ASK示範如下<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/8Z71CMF.png" src="/img/loading.gif" class="lazyload" title></a><br>由此可以知道，今天就算有雜訊干擾，我依然可以數位的特性判斷波形是0還是1，所以數位的抗雜訊較優，以前的電視機都是類比通訊，當有雜訊干擾，就會有雪花和嘶嘶嘶嘶嘶的聲音，但是數位不會，可是數位通訊可能會因為雜訊干擾，畫面就卡住，因為接收到的數位訊號被雜訊干擾無法轉換成圖像，電視就無法得到下一秒的畫面。</p><h3 id="➤類比訊號-gt-數位傳輸："><a href="#➤類比訊號-gt-數位傳輸：" class="headerlink" title="➤類比訊號-&gt;數位傳輸："></a>➤類比訊號-&gt;數位傳輸：</h3><p>如何將連續的類比訊號用數位方式來傳輸和呈現，就必然需要將類比訊號轉換成數位，其轉換請參考音檔的誕生篇，此處不再進行描述。</p><h3 id="➤數位訊號-gt-數位傳輸："><a href="#➤數位訊號-gt-數位傳輸：" class="headerlink" title="➤數位訊號-&gt;數位傳輸："></a>➤數位訊號-&gt;數位傳輸：</h3><p>數位訊號的1就是高電壓5V，0就是0V，然後透過導線傳輸電壓的組合(0和1的組合)，主要用於PCB版上，IC與IC之間的訊息傳輸，但是根據物理法則，導線越長，電阻越大，那麼傳輸的5V，因為導線電阻太大，接收端拿到只剩下0.2V，於是接收端判斷為該數據是0，而不是1(詳細半導體架構請參考程式的誕生)，故這種數位訊號，數位傳輸，只能運用在小範圍的距離。<br>而為了讓資料傳輸得更遠，並且可靠性更高，於是有了幾種編碼方式是：</p><h4 id="RS-232C-編碼："><a href="#RS-232C-編碼：" class="headerlink" title="RS-232C 編碼："></a>RS-232C 編碼：</h4><p>上述範例使用5V代表1，0V代表0，這樣差距太小，容易衰變導致0.2V問題，於是提高差距<br>0：正電壓（+12V）。<br>1：負電壓（-12V)。</p><h4 id="差動式零補差編碼："><a href="#差動式零補差編碼：" class="headerlink" title="差動式零補差編碼："></a>差動式零補差編碼：</h4><p>0：位元時間內電位由高電位變低電位，或由低電位變為高電位<br>1：位元時間內無電位變化。</p><h4 id="曼徹斯特編碼："><a href="#曼徹斯特編碼：" class="headerlink" title="曼徹斯特編碼："></a>曼徹斯特編碼：</h4><p>0：位元中間由高電位變化到低電位（high → low）。<br>1：位元中間由低電位變化到高電位（low → high）。</p><h4 id="差動式曼徹斯特編碼："><a href="#差動式曼徹斯特編碼：" class="headerlink" title="差動式曼徹斯特編碼："></a>差動式曼徹斯特編碼：</h4><p>在每一位元時間的中間都有電位變化（high →low 或 low →high）。<br>0：位元時間的起始有變化，起始時間可能由高電位轉換到低電位，或由低電位變化到高電位（high →  low 或 low →  high）。<br>1：位元的時間起始沒有變化。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/BS6SsQQ.png" src="/img/loading.gif" class="lazyload" title></a></p><p>上面介紹了調變的技術，在介紹多工前我們先理解，資料通訊的類型有什麼</p><h3 id="線路交換："><a href="#線路交換：" class="headerlink" title="線路交換："></a>線路交換：</h3><p>指傳送端與接收端之間先建立一條專用的連線，再使用不同的調變技術進行通訊，傳統的「語音通信(Telecom)」都是屬於線路交換，<br>Ex：台北的有線電話在使用前必須先撥號，經由長途電話交換中心轉接到高雄的有線電話，使用者才能通話。<br>傳統的國內電話與國際電話、行動電話等在通話之前都必須先撥號，等交換機將電話接通之後才可以通話，就是使用線路交換的方式，通常費用是以「使用時間」計算，例如：撥打市內電話或行動電話，使用愈久費用愈高。</p><h3 id="封包交換："><a href="#封包交換：" class="headerlink" title="封包交換："></a>封包交換：</h3><p>是指傳送端與接收端之間共用一條線路，必須先將要傳送的資料切割成許多較小的「封包(Packet)」，再使用不同的多工技術進行通訊，目前的「資料通信(Datacom)」都是屬於封包交換</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/9Npf0SB.png" src="/img/loading.gif" class="lazyload" title></a></p><p>由圖可以知道，如果今天你和你哥共用同一個WIFI 熱點，你哥要下載1G的檔案，你也要下載1M的檔案，而沒有多工技術的話，你就必須等他下載完1G才輪到你，根本沒道理阿!!!<br>於是把1G分成1000個1M封包，你哥先下載第一個1M，再換你下載1M，這樣才叫做公平!!!，更何況天空只有一個，你要丟你的電磁波，我也要丟，要如何公平並且區分誰是誰的呢，所以下面介紹各種多工技術</p><h3 id="分時多工-TDMA-："><a href="#分時多工-TDMA-：" class="headerlink" title="分時多工(TDMA)："></a>分時多工(TDMA)：</h3><p>使用者依照「時間先後」輪流使用一條資訊通道，我們稱為「分時多工接取(TDMA)」。假設資料通道只有一個，但是有三個人要使用，則最簡單的方法就是A先傳送資料，再換B、再換C、再輪回A，再換B、再換C，依此類推。</p><p>Ex：就好像有一條很窄的吊橋，同時只能讓一個人正面通過，但是有三個人要過橋，最簡單的方法就是A先過、再換B、再換C囉</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/BsD8gPC.png" src="/img/loading.gif" class="lazyload" title></a></p><p>使用該技術最出名的產品是： 2G(GSM)，第二代行動通訊，Nokia 3310就是2G手機</p><h3 id="分頻多工-FDMA-："><a href="#分頻多工-FDMA-：" class="headerlink" title="分頻多工(FDMA)："></a>分頻多工(FDMA)：</h3><p>使用者依照「頻率不同」同時使用一條資訊通道，我們稱為「分頻多工接取(FDMA)」。假設資料通道只有一個，但是有三個人要使用，而且三個人都要同時傳送，則只好先將資料通道依照不同的頻率切割成三等分，再將A、B、C的資料同時傳送，由於資料通道被切割成三等分，所以每個人只能使用原來1/3的頻寬來傳送資料，需要比較長的時間。就好像有一條很窄的吊橋，同時只能讓一個人正面通過，但是同時有三個人要過橋，而且三個人又互不相讓，怎麼辦呢？只好委屈一點，側身走，但是速度比較慢。</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/6X4jZdw.png" src="/img/loading.gif" class="lazyload" title></a></p><p>使用該技術最出名的產品是： 電視，電視有某個頻率，然後電視把頻率分成好幾個小頻率，每個小頻率就是一個電視台，中天、台視等等。</p><h6 id="但是因為分開頻率，為避免兩者頻率有干擾，所以需要保護帶，就是51台和52台中間其實有段頻譜是不能使用，避免干擾問題。"><a href="#但是因為分開頻率，為避免兩者頻率有干擾，所以需要保護帶，就是51台和52台中間其實有段頻譜是不能使用，避免干擾問題。" class="headerlink" title="但是因為分開頻率，為避免兩者頻率有干擾，所以需要保護帶，就是51台和52台中間其實有段頻譜是不能使用，避免干擾問題。"></a>但是因為分開頻率，為避免兩者頻率有干擾，所以需要保護帶，就是51台和52台中間其實有段頻譜是不能使用，避免干擾問題。</h6><h3 id="分碼多工-CDMA-："><a href="#分碼多工-CDMA-：" class="headerlink" title="分碼多工(CDMA)："></a>分碼多工(CDMA)：</h3><p>將不同使用者的資料分別與特定的「密碼(Code)」運算以後，再傳送到資料通道，接收端以不同的密碼來分辨要接收的訊號，使用在CDMA上的密碼又稱為「正交展頻碼(Orthogonal spreading code)」。假設資料通道只有一個，但是有三個人要使用，而且三個人都要同時傳送，又不想要將頻率切割成三等分，真是又要馬兒跑又要馬兒不吃草，怎麼辦呢？由於手機的元件都是「只認頻率不認人」，如果三個人都使用相同的頻率，則手機無法分辨(會同時聽到三個人的聲音)，科學家們想到，如果能夠在A、B、C傳送的數位訊號裡加入特定的密碼，則接收端只要分辨不同的密碼就可以選擇接收正確的數位訊號囉！</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/uZyI8so.png" src="/img/loading.gif" class="lazyload" title></a></p><p>CDMA技術對於頻寬的使用效率比FDMA或TDMA更好，因為CDMA可以讓多個使用者同時使用相同的頻寬來傳送資料，再由接收端根據不同的密碼解讀資料，不像FDMA或TDMA都必須分配一個固定的頻寬或固定頻寬中的某一段時間，因此CDMA技術可以大幅增加原本FDMA或TDMA技術所能容納的使用者數目。</p><p>使用該技術最出名的產品是： 3G手機，但是也因為加密關係，他會從十幾個封包每個進行解密計算，確認其中哪一個是屬於你的，而這過程會更浪費電力，CPU會更耗電，所以把網路關閉會節約很多電量。</p><h6 id="因為CDMA原本是美國軍方開發的，後來開放，被改良成WCDMA，如今大部分都使用WCDMA而不是CDMA"><a href="#因為CDMA原本是美國軍方開發的，後來開放，被改良成WCDMA，如今大部分都使用WCDMA而不是CDMA" class="headerlink" title="因為CDMA原本是美國軍方開發的，後來開放，被改良成WCDMA，如今大部分都使用WCDMA而不是CDMA"></a>因為CDMA原本是美國軍方開發的，後來開放，被改良成WCDMA，如今大部分都使用WCDMA而不是CDMA</h6><h3 id="正交分頻多工-OFDM-："><a href="#正交分頻多工-OFDM-：" class="headerlink" title="正交分頻多工(OFDM)："></a>正交分頻多工(OFDM)：</h3><p>上述多工，都不是效率最高的多工技術，目前效率最高的多工技術就是OFDM，該多工是改良FDMA，而改良方法是正交的多載波傳輸技術，指的是將可用的頻譜分割成多個子載波，每個子載波可以載送一低速資料流程，並且相互正交，所以不需要保護帶，頻譜利用率更高，如下。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/OE3M6qL.png" src="/img/loading.gif" class="lazyload" title></a><br>使用該技術最出名的產品是： 4G手機、Wifi。</p><p>上述介紹了多工技術，如何使用這些技術讓頻譜的使用率更高。<br>在兩個通訊設備之間的連線稱之為『通訊鏈路』，因為接收和傳送裝置的不同，像是麥克風要傳送，那麼它有接收功能嗎?，所以其通訊鏈路的方向性就不同，於是我們釐清一下三種方向性：</p><h3 id="單工："><a href="#單工：" class="headerlink" title="單工："></a>單工：</h3><p>資料只能單向傳送，由一端傳送到另一端，EX：電視、收音機、外帶號碼呼叫牌，等等</p><h3 id="半雙工："><a href="#半雙工：" class="headerlink" title="半雙工："></a>半雙工：</h3><p>半雙工是指資料可以雙向傳送，但是同一個時間只有一個方向可以傳送，EX：無線對講機，講完一句話都要講Over，之後放開按鈕等對方說話，無法在對方講話時後加入話題，只能等他講完</p><h3 id="全雙工："><a href="#全雙工：" class="headerlink" title="全雙工："></a>全雙工：</h3><p>全雙工是指資料可以同時雙向傳送，EX：電話</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/lWtSVK5.png" src="/img/loading.gif" class="lazyload" title></a></p><p>上述講述了實體層的定義，以及各種實體電子元件是怎麼傳送資料給別人的，那麼我們繼續看OSI第二層資料連結層。</p>]]></content>
      
      
      <categories>
          
          <category> 通訊協定系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
            <tag> 協定 </tag>
            
            <tag> 無線通訊 </tag>
            
            <tag> 有線通訊 </tag>
            
            <tag> 4G </tag>
            
            <tag> 5G </tag>
            
            <tag> OSI </tag>
            
            <tag> 實體層 </tag>
            
            <tag> TCP/IP協定 </tag>
            
            <tag> 電磁波 </tag>
            
            <tag> 調變 </tag>
            
            <tag> 多工 </tag>
            
            <tag> 雙工 </tag>
            
            <tag> 類比 </tag>
            
            <tag> 數位 </tag>
            
            <tag> AM </tag>
            
            <tag> FM </tag>
            
            <tag> PM </tag>
            
            <tag> 1G </tag>
            
            <tag> 2G </tag>
            
            <tag> 3G </tag>
            
            <tag> ASK </tag>
            
            <tag> FSK </tag>
            
            <tag> PSK </tag>
            
            <tag> BPSK </tag>
            
            <tag> QPSK </tag>
            
            <tag> 16PSK </tag>
            
            <tag> QAM </tag>
            
            <tag> 雜訊 </tag>
            
            <tag> RS-232C編碼 </tag>
            
            <tag> 差動式零補差編碼 </tag>
            
            <tag> 曼徹斯特編碼 </tag>
            
            <tag> 差動式曼徹斯特編碼 </tag>
            
            <tag> 線路交換 </tag>
            
            <tag> 封包交換 </tag>
            
            <tag> TDMA </tag>
            
            <tag> FDMA </tag>
            
            <tag> CDMA </tag>
            
            <tag> OFDM </tag>
            
            <tag> 單工 </tag>
            
            <tag> 半雙工 </tag>
            
            <tag> 全雙工 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通訊P.02 - OSI七層模型</title>
      <link href="/2021/04/02/%E9%80%9A%E8%A8%8AP.02%20-%20OSI%E4%B8%83%E5%B1%A4%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/04/02/%E9%80%9A%E8%A8%8AP.02%20-%20OSI%E4%B8%83%E5%B1%A4%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="通訊協定模型-OSI模型："><a href="#通訊協定模型-OSI模型：" class="headerlink" title="通訊協定模型 OSI模型："></a>通訊協定模型 OSI模型：</h1><p>以上的舉例，時間定義、嘟聲定義，都是平日生活的協定，但是整個通訊傳輸(包含網路傳輸)的協定，都是基於一個模型而制定的，包含802系列的協定<br>制定模型的單位是ISO組織，該模型大概長這樣<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/ArHN2ev.png" src="/img/loading.gif" class="lazyload" title></a></p><p>其實在這個模型制定前，就已經存在通訊傳輸了，最早的網路是由美國國防高等研究計劃署(ARPA)制定，ARPA制定的是TCP/IP協定模型，之後通訊傳輸民用化(跟GPS一樣)，於是ISO組織以TCP/IP協定模型為框架模型，制定出OSI 7層抽象模型</p><p>今天我要傳遞資料給別人，就必須經過這七層，而這七層，每層都會進行特別處理，就像是日常生活，假設我是A公司的老闆，我要寫信給B公司，就會經過七層進行處理，每層都會進行各自的業務，情況如下</p><h6 id="請注意，OSI各層的處理業務，並非圖中所表，該圖只是說明-分層負責-的概念，每層都會負責自己的業務"><a href="#請注意，OSI各層的處理業務，並非圖中所表，該圖只是說明-分層負責-的概念，每層都會負責自己的業務" class="headerlink" title="請注意，OSI各層的處理業務，並非圖中所表，該圖只是說明 分層負責 的概念，每層都會負責自己的業務"></a>請注意，OSI各層的處理業務，並非圖中所表，該圖只是說明 分層負責 的概念，每層都會負責自己的業務</h6><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/GbhyzYd.png" src="/img/loading.gif" class="lazyload" title></a></p><p>所以可以從上圖得知，OSI七層都有自己要做的事情，而每層要做的事情，如下圖：</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/oowsynu.png" src="/img/loading.gif" class="lazyload" title></a></p><p>所以可以把七層視為七隻程式或產品，每隻程式或產品要做的事情都不一樣，而今天我要傳送一封信，那麼信的內容就叫做封包，而每層處理完自己的業務，都會把業務成果放在封包前後(除了實體層，因為實體層業務是傳輸)，放置於前面的叫做表頭，放置於後面的叫做表尾</p><p>就像是</p><ul><li>老闆寫完信後，放入信封，給予總經理寫建議</li><li>總經理寫完後，又拿個信封包起來，給予部長寫風險評估</li><li>部長寫完後，又拿個信封包起來….etc </li></ul><p><strong>最後傳到B公司，B公司在一層一層的拆開，而</strong></p><ul><li>只有B公司部長能拆A公司部長的信封</li><li>只有B公司總經理能拆A公司總經理的信封</li><li>只有B公司老闆能拆A公司老闆的信封</li></ul><h6 id="以下給予編號，以便知道這個表頭和表尾是誰給的"><a href="#以下給予編號，以便知道這個表頭和表尾是誰給的" class="headerlink" title="以下給予編號，以便知道這個表頭和表尾是誰給的"></a>以下給予編號，以便知道這個表頭和表尾是誰給的</h6><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/IuNtIlH.png" src="/img/loading.gif" class="lazyload" title></a></p><p>下一章進行各層詳細敘述以及特殊運用。</p>]]></content>
      
      
      <categories>
          
          <category> 通訊協定系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
            <tag> 協定 </tag>
            
            <tag> 無線通訊 </tag>
            
            <tag> 有線通訊 </tag>
            
            <tag> ISO </tag>
            
            <tag> OSI </tag>
            
            <tag> 實體層 </tag>
            
            <tag> TCP/IP協定 </tag>
            
            <tag> 應用層 </tag>
            
            <tag> 表現層 </tag>
            
            <tag> 會議層 </tag>
            
            <tag> 傳輸層 </tag>
            
            <tag> 網路層 </tag>
            
            <tag> 資料鏈結層 </tag>
            
            <tag> ARPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.14 - 單元測試Mocha</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.14%20-%20%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6Mocha/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.14%20-%20%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6Mocha/</url>
      
        <content type="html"><![CDATA[<h1 id="單元測試（Unit-Test）："><a href="#單元測試（Unit-Test）：" class="headerlink" title="單元測試（Unit Test）："></a>單元測試（Unit Test）：</h1><p>就是以程式中最小的邏輯單元寫測試程式，來驗證邏輯是否正確。一般來說，程式中最小的邏輯單元是函式(function)，或方法(method)。</p><h1 id="為什麼要做-Unit-Test？"><a href="#為什麼要做-Unit-Test？" class="headerlink" title="為什麼要做 Unit Test？"></a>為什麼要做 Unit Test？</h1><ul><li>今天流程是： 拿杯子 -&gt; 裝熱水 -&gt; 拿熱水壺 -&gt; 倒入水杯，如果因為修改了拿杯子這個函數，導致後面三個函數都執行失敗，於是你從倒入水杯往回追，浪費一堆時間。所以為了避免Bug的連動性，盡早知道是 拿杯子 這個單元錯誤。</li><li>更快速指出問題點、並顯示正確的是什麼，減少Code Review時間。</li><li>先搞懂自己的code要做什麼。然後再讓它完成任務。</li><li>先寫測試強迫你寫code前先做規劃</li></ul><h1 id="Mocha："><a href="#Mocha：" class="headerlink" title="Mocha："></a>Mocha：</h1><p>以上就是單元測試的說明，那麼我來回顧，首先我們知道怎麼運用WebPack將我們的程式打包再一起，但是沒有進行單元測試，所以只能靠電腦Run Porces時才知道有問題，知道問題後CodeReview一段時間才知道，哪個函數錯誤、應該要出現的結果等等，明顯浪費了一些時間。</p><p>Mocha就是一款基於NodeJS開發的工具，主要功能就是實現單源測，你可以輸入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init -y </span><br><span class="line">npm i -d mocha</span><br></pre></td></tr></table></figure></div><p>進行下載並安裝，然後於package.json的任務加入以下實作內容：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;mocha &#39;test&#x2F;**&#x2F;test-*.js&#39;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;mocha&quot;: &quot;^7.0.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>這邊完成後我們來布置環境，首先找出你的源碼：</p><p>MathObj.js丟入根目錄的src資料夾內：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.add &#x3D; add;</span><br></pre></td></tr></table></figure></div><p>然後我們開始撰寫測試碼：</p><p>test-MathObj.js丟入根目錄的test資料夾內：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const MathObj &#x3D; require(&#39;.&#x2F;..&#x2F;src&#x2F;MathObj&#39;);</span><br><span class="line"></span><br><span class="line">describe(&#39;測試add函數&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    it(&#39;測試5+5預期10&#39;, () &#x3D;&gt; &#123; if (MathObj.add(5, 5) !&#x3D;&#x3D; 10) throw new Error(&quot;兩數相加結果不為兩數和&quot;); &#125;)</span><br><span class="line">    it(&quot;測試-2+2預期0&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        var t &#x3D; -2;</span><br><span class="line">        var g &#x3D; 2;</span><br><span class="line">        if (MathObj.add(t, g) !&#x3D;&#x3D; t + g)</span><br><span class="line">            throw new Error(&quot;Not eq zero&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>describe描述狀態或圈出特定區塊，解釋測試的功能，就是解釋用的。<br>it是一個測試項目，必須於裡面丟出 error或是例外才能知道是否成功，否則當執行到函數壽命結束都算是成功。</p><p>以上就是簡單的測試範例，之後輸入指令</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></div><p>就可以順利執行獲得結果。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/XSKnjvT.png" src="/img/loading.gif" class="lazyload" title></a></p><h1 id="導入WebPack："><a href="#導入WebPack：" class="headerlink" title="導入WebPack："></a>導入WebPack：</h1><p>上面的功能能夠讓你進行測試，但是如果能導入CI/CD就更好，更方便的自動化環境，並且如果測試範圍夠廣的話就具有很好的測試品質，而我們可以將測試功能加入自動化流程內，也就是WebPack</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/UcNtB3z.png" src="/img/loading.gif" class="lazyload" title></a></p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/GzHCR45.png" src="/img/loading.gif" class="lazyload" title></a></p><p>上述是來自webpack的官網說明(還有很多擴充選項可以使用，這邊不進行示範)，我們依照上述說明並改寫成我們的檔案名稱，之後webpack.config.js應該會長這樣：</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/4ekN8NS.png" src="/img/loading.gif" class="lazyload" title></a></p><p>package.json 會長這樣：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/HwK3utH.png" src="/img/loading.gif" class="lazyload" title></a></p><p>之後我們輸入指令進行執行，會得到dist資料夾內的一個bundle.js程式碼，這檔案就是使用Mocha處理指定的檔案後加上WebPack打包的程式碼，這程式碼是Mocha的一個結果報告，將這個報告用Html方式打開(LiveServer或是webpack的http系列工具)：</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/gID3dcP.png" src="/img/loading.gif" class="lazyload" title></a></p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> npm </tag>
            
            <tag> packeage.json </tag>
            
            <tag> WebPack </tag>
            
            <tag> Mocha </tag>
            
            <tag> 單元測試 </tag>
            
            <tag> CI/CD </tag>
            
            <tag> CI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通訊P.01 - 協定</title>
      <link href="/2021/04/02/%E9%80%9A%E8%A8%8AP.01%20-%20%E5%8D%94%E5%AE%9A/"/>
      <url>/2021/04/02/%E9%80%9A%E8%A8%8AP.01%20-%20%E5%8D%94%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>我們先來個破題，我們最終要探討的是WebSocket這個網路傳輸的協定，而在這過程會用到的技術都會一併討論。<br>首先WebSocket是一種網路傳輸協定，而什麼是協定？</p><h1 id="協定："><a href="#協定：" class="headerlink" title="協定："></a>協定：</h1><p>為了要讓所有設備都能夠相互交互資料，我們必須要有一個協定，假設你要跟一個人聊天，那麼你們勢必要用同一種語言才能進行溝通，協定亦是如此，更何況網路傳輸的是一堆0和1，那麼你協定也必然要定義前8個0和1是代表什麼意思，後20個0和1是代表什麼意思，這就是網路傳輸的協定</p><h2 id="制定協定的組織："><a href="#制定協定的組織：" class="headerlink" title="制定協定的組織："></a>制定協定的組織：</h2><p>今天你要跟我溝通，我們可以建立一個協定，<br>你：Lucas好帥，今天天氣怎樣<br>我：蔡依林好美，今天很冷<br>我們制訂了一個協定，當你說出關鍵字Lucas好帥，就是與我對話，當我說出蔡依林好美，就是我在跟你說話，而如果你沒說Lucas好帥，我就不知道你在跟誰講話？是在跟王力宏還是馬英九講話？這就是一個簡單協定。</p><p>但是這個協定只有你和我知道，所以要讓其他人知道，我們的話語權不夠，於是制定協定的人，必須是公信力的大組織，以下舉例：</p><h3 id="國際電信聯盟-ITU-：聯合國分支機構，主要負責確立國際無線電和電信的管理制度與通訊規則，主要包括下列三個委員會："><a href="#國際電信聯盟-ITU-：聯合國分支機構，主要負責確立國際無線電和電信的管理制度與通訊規則，主要包括下列三個委員會：" class="headerlink" title="國際電信聯盟(ITU)：聯合國分支機構，主要負責確立國際無線電和電信的管理制度與通訊規則，主要包括下列三個委員會："></a>國際電信聯盟(ITU)：聯合國分支機構，主要負責確立國際無線電和電信的管理制度與通訊規則，主要包括下列三個委員會：</h3><p>➤世界頻率註冊委員會(IFRB)<br>➤國際無線電委員會(CCIR)<br>➤國際電報電話咨詢委員會(CCITT)</p><p>這邊舉個例子，為什麼我們撥打電話時候都會有嘟聲，而長嘟聲和短嘟聲都有特別意義<br>為什麼當你按下撥號的1會發出一個 嘟聲，而按下2會發出另一個 嘟聲，這就是CCITT制定的</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/v0W50aj.png" src="/img/loading.gif" class="lazyload" title></a></p><p>由表可以看出，1的嘟聲是由一個頻率 1209 和 697 Hz合成的聲音(詳細請參考傅立葉轉換篇)</p><p>而這些特別的嘟聲傳到你的電信業者的電信交換器，電信交換器經由特別的嘟聲判斷你按下的是什麼按鍵，所以電信交換器壞了，就無法通話<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/0X4HS4V.png" src="/img/loading.gif" class="lazyload" title></a></p><p>因為電話設備是能夠撥打國外的電話，那麼台灣用的嘟聲和美國用的嘟聲不同，台灣打給美國，台灣1的嘟聲在美國對應的是8，那原本要打給女朋友的電話，結果接起電話是隔壁老王，這樣雙方就沒辦法溝通，於是才有聯合國制定統一的協定。</p><h6 id="網紅啾啾鞋嘗試過，撥打客服，客服說需要英文服務請按1，這時候啾啾鞋沒按下1，而是播放1的嘟聲，結果居然切換到英文模式，因為客服判斷是不是按下1，也是依靠聲音的頻率而定，所以這也是協定的好處。"><a href="#網紅啾啾鞋嘗試過，撥打客服，客服說需要英文服務請按1，這時候啾啾鞋沒按下1，而是播放1的嘟聲，結果居然切換到英文模式，因為客服判斷是不是按下1，也是依靠聲音的頻率而定，所以這也是協定的好處。" class="headerlink" title="網紅啾啾鞋嘗試過，撥打客服，客服說需要英文服務請按1，這時候啾啾鞋沒按下1，而是播放1的嘟聲，結果居然切換到英文模式，因為客服判斷是不是按下1，也是依靠聲音的頻率而定，所以這也是協定的好處。"></a>網紅啾啾鞋嘗試過，撥打客服，客服說需要英文服務請按1，這時候啾啾鞋沒按下1，而是播放1的嘟聲，結果居然切換到英文模式，因為客服判斷是不是按下1，也是依靠聲音的頻率而定，所以這也是協定的好處。</h6><h3 id="國際標準組織-ISO-：目的是為了加速工業標準之國際化與單一化、促進貨品與服務的國際交換，發展全球智慧財產權、科學、技術與經濟活動的合作，最重要的包括下列規範："><a href="#國際標準組織-ISO-：目的是為了加速工業標準之國際化與單一化、促進貨品與服務的國際交換，發展全球智慧財產權、科學、技術與經濟活動的合作，最重要的包括下列規範：" class="headerlink" title="國際標準組織(ISO)：目的是為了加速工業標準之國際化與單一化、促進貨品與服務的國際交換，發展全球智慧財產權、科學、技術與經濟活動的合作，最重要的包括下列規範："></a>國際標準組織(ISO)：目的是為了加速工業標準之國際化與單一化、促進貨品與服務的國際交換，發展全球智慧財產權、科學、技術與經濟活動的合作，最重要的包括下列規範：</h3><p>➤ISO/IEC7498：定義了網際網路互相聯結的七層架構，也就是開放式系統互連模型(OSI)，這個模型後來被廣泛應用到所有的有線與無線通訊領域。<br>➤ISO 31-1：時間的定義 (秒)<br>➤ISO 216： A4 的紙是多寬和多長<br>➤ISO 6709： 經度、緯度、海拔 的定義和表示法</p><p>再舉個例子，時間的定義：</p><p>一秒是多久? 為什麼不能是我從台北到高雄的時間叫做1秒？很久以前一秒的定義是一天的 86000/1 ，也就是一天 = 24小時 = 1440 分鐘 = 860000秒，那麼一秒是基於一天而定義出來，那一天是什麼?</p><p>一天是當太陽第一次上升到最高點時後，之後第二次升到最高點的時間差，<del>說人話就是今天中午到明天中午的時間差</del>，這就叫做真太陽時，但是隨著科技進步，發現地球是橢圓的，導致地球公轉時每個真太陽時都不是固定的，於是科學家觀察把一個周期內的所有真太陽時加起來取平均，這叫做平太陽時，一天就是平太陽時</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/1FnDcg9.png" src="/img/loading.gif" class="lazyload" title></a></p><p>又經過一段時間，科技進步，科學家發現因為地球的地軸會輕微的改變，導致每次計算的平太陽時都不相同</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/ACmMq2N.png" src="/img/loading.gif" class="lazyload" title></a></p><p>其根本問題是太陽為非穩定的觀測對象，於是科學家們修改秒的定義，從宏觀到微觀</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/0DdKqh4.png" src="/img/loading.gif" class="lazyload" title></a></p><p>現在的一秒定義就是銫原子在切換能階(b和c)的頻率，銫原子要切換能階必須要一個固定的頻率，因為能階非常精小，所以頻率是非常固定的常數，我們用愛因斯坦的公式+暴力破解方法，找出銫原子的能階頻率：9192631770 Hz</p><p>這就是一秒的定義，用電路震盪9192631770次後，就是經過了一秒，用這種全新方式定義一秒，又稱為原子時，大概3億年才會誤差1秒</p><h6 id="銫原子的頻率尋找演算法，很有意思，不難，是個很好玩的演算法，真心推薦，詳情請觀看-秒的定義-篇"><a href="#銫原子的頻率尋找演算法，很有意思，不難，是個很好玩的演算法，真心推薦，詳情請觀看-秒的定義-篇" class="headerlink" title="銫原子的頻率尋找演算法，很有意思，不難，是個很好玩的演算法，真心推薦，詳情請觀看 秒的定義 篇"></a>銫原子的頻率尋找演算法，很有意思，不難，是個很好玩的演算法，真心推薦，詳情請觀看 秒的定義 篇</h6><h3 id="美國電子電機工程師學會-IEEE-：由於美國為科技大國，再加上網際網路起源於美國，所以IEEE是目前通訊領域最重要的組織之一，制定的通訊標準涵蓋整個有線與無線通訊領域，由於技術的進步規範的內容也愈來愈多，主要包括下列幾項："><a href="#美國電子電機工程師學會-IEEE-：由於美國為科技大國，再加上網際網路起源於美國，所以IEEE是目前通訊領域最重要的組織之一，制定的通訊標準涵蓋整個有線與無線通訊領域，由於技術的進步規範的內容也愈來愈多，主要包括下列幾項：" class="headerlink" title="美國電子電機工程師學會(IEEE)：由於美國為科技大國，再加上網際網路起源於美國，所以IEEE是目前通訊領域最重要的組織之一，制定的通訊標準涵蓋整個有線與無線通訊領域，由於技術的進步規範的內容也愈來愈多，主要包括下列幾項："></a>美國電子電機工程師學會(IEEE)：由於美國為科技大國，再加上網際網路起源於美國，所以IEEE是目前通訊領域最重要的組織之一，制定的通訊標準涵蓋整個有線與無線通訊領域，由於技術的進步規範的內容也愈來愈多，主要包括下列幾項：</h3><p>➤IEEE802.1：內部網路與系統管理。<br>➤IEEE802.2：邏輯連結控制(LLC：Logical Link Control)。<br>➤IEEE802.3：載波偵測多重存取／碰撞偵測(CSMA/CD)，應用在乙太網路。<br>➤IEEE802.4：記號匯流排網路(Token bus)。<br>➤IEEE802.5：記號環網路(Token ring)。<br>➤IEEE802.6：都會區域網路(MAN：Metropolitan Area Network)。<br>➤IEEE802.7：寬頻網路技術(Broadband network)。<br>➤IEEE802.8：光纖光纜技術(Fiber network) 。<br>➤IEEE802.9：語音與資料整合通信(VoIP：Voice over IP)，應用在網路電話。<br>➤IEEE802.10：網路安全技術(Network security)。<br>➤IEEE802.11：無線區域網路(WLAN：Wireless Local Area Network)。<br>➤IEEE802.12：高速區域網路(High-speed Local Area Network)。<br>➤IEEE802.13：高速乙太網路(High-speed Ethernet)。<br>➤IEEE802.14：有線電視網路(CATV：Community Antenna TV)。<br>➤IEEE802.15：無線個人區域網路(WPAN：Wireless Personal Area Network)。<br>➤IEEE802.16：無線寬頻接取技術(Wireless MAN)，主要應用在WiMAX。<br>➤IEEE802.17：彈性封包環網路(Resilient packet ring)。</p><p>此處用802.11進行舉例，這是無線網路的協定，這個協定又細分很多種小協定</p><ul><li>802.11b：在2.4G HZ的ISM頻率通道上，最快11Mbit/s</li><li>802.11a：在5G HZ的頻率通道上，最快54Mbit/s</li><li>802.11g：在2.4G HZ的ISM頻率通道上，最快54Mbit/s</li><li>802.11n：可在2.4G 、 5G  HZ頻率通道上，最快為216.7MBit/s和450Mbit/s</li><li>802.11ac：在5G HZ的頻率通道上，最快為 1.7Gbit/s</li><li>802.11ax：可在2.4G 、 5G  HZ頻率通道上，最快為2.4 Gbit/s</li></ul><p>這些小協定又稱為第N代Wifi世代，該小協定制定了Wifi使用的頻率通道，並且也制定了使用技術，帶寬等等是多少，也就是說Wifi能多快，除了硬體設備影響，其中最核心的影響還是協定</p><p>為什麼要制定這些小協定?</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/LkDwDwC.png" src="/img/loading.gif" class="lazyload" title></a></p><p>首先頻率通道是非常珍貴的，所有無線訊號都必須依靠頻道才能傳送，假設4G(第四代行動通訊)使用了3G Hz的頻道，那麼這個頻道就不允許其他人使用，如果各國自己訂自己的頻率那就會有很嚴重的問題</p><p>今天美國做的IPhone，他的網卡只能接收2.4G Hz，而這個頻率剛好是美國Wifi的上網頻道，那麼如果他去台灣發現，台灣上網頻道是8.7G Hz，那麼IPhone就沒辦法上網了，就算裝上台灣SIM卡也無法上網，因為它接收不到台灣上網頻道，所以這就是為什麼要制定全世界都必須遵守的協定</p><h6 id="因為頻道無法重複利用，協定定義了5G-第五代行動通訊-可以使用的頻道，而台灣NCC將5G可以使用的頻段切分出來，讓各個電信業者進行獨佔，其中5G熱門的頻段-3500MHz-競標到天價456-75億元-中華電信就是有錢-，由此可以看出頻段的珍貴"><a href="#因為頻道無法重複利用，協定定義了5G-第五代行動通訊-可以使用的頻道，而台灣NCC將5G可以使用的頻段切分出來，讓各個電信業者進行獨佔，其中5G熱門的頻段-3500MHz-競標到天價456-75億元-中華電信就是有錢-，由此可以看出頻段的珍貴" class="headerlink" title="因為頻道無法重複利用，協定定義了5G(第五代行動通訊) 可以使用的頻道，而台灣NCC將5G可以使用的頻段切分出來，讓各個電信業者進行獨佔，其中5G熱門的頻段 3500MHz 競標到天價456.75億元(中華電信就是有錢)，由此可以看出頻段的珍貴"></a>因為頻道無法重複利用，協定定義了5G(第五代行動通訊) 可以使用的頻道，而台灣NCC將5G可以使用的頻段切分出來，讓各個電信業者進行獨佔，其中5G熱門的頻段 3500MHz 競標到天價456.75億元(中華電信就是有錢)，由此可以看出頻段的珍貴</h6><h6 id="買手機時也應該看手機能接收的頻段，如果手機能接收2-412M-Hz，但是你申辦的是亞太，他提供的上網頻段沒有2-412M-Hz，你手機就無法上網"><a href="#買手機時也應該看手機能接收的頻段，如果手機能接收2-412M-Hz，但是你申辦的是亞太，他提供的上網頻段沒有2-412M-Hz，你手機就無法上網" class="headerlink" title="買手機時也應該看手機能接收的頻段，如果手機能接收2.412M Hz，但是你申辦的是亞太，他提供的上網頻段沒有2.412M Hz，你手機就無法上網"></a>買手機時也應該看手機能接收的頻段，如果手機能接收2.412M Hz，但是你申辦的是亞太，他提供的上網頻段沒有2.412M Hz，你手機就無法上網</h6><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/nhmxTx2.png" src="/img/loading.gif" class="lazyload" title></a></p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/g4OsPEh.png" src="/img/loading.gif" class="lazyload" title></a></p><h6 id="台灣的5G，目前中華電信競拍最多頻段，所以理論上5G時代，中華電信的上網品質會比較好"><a href="#台灣的5G，目前中華電信競拍最多頻段，所以理論上5G時代，中華電信的上網品質會比較好" class="headerlink" title="台灣的5G，目前中華電信競拍最多頻段，所以理論上5G時代，中華電信的上網品質會比較好"></a>台灣的5G，目前中華電信競拍最多頻段，所以理論上5G時代，中華電信的上網品質會比較好</h6><h6 id="ISM是指說2-4G-頻道內，可以免費使用的頻率，不用特意申請和付費，用於科學、教育、工業等運用，也因為它是免費的，所以該頻段很容易後到干擾"><a href="#ISM是指說2-4G-頻道內，可以免費使用的頻率，不用特意申請和付費，用於科學、教育、工業等運用，也因為它是免費的，所以該頻段很容易後到干擾" class="headerlink" title="ISM是指說2.4G 頻道內，可以免費使用的頻率，不用特意申請和付費，用於科學、教育、工業等運用，也因為它是免費的，所以該頻段很容易後到干擾"></a>ISM是指說2.4G 頻道內，可以免費使用的頻率，不用特意申請和付費，用於科學、教育、工業等運用，也因為它是免費的，所以該頻段很容易後到干擾</h6><h6 id="頻段的使用定義，雖然由IEEE制定，但某些國家還是有限制，像是802-11ax-有些頻段在大陸是禁用的，如果隨意使用某些通道，有可能被查水表，但通常製作Wifi-AP的公司會禁用該通道才出口到指定國家"><a href="#頻段的使用定義，雖然由IEEE制定，但某些國家還是有限制，像是802-11ax-有些頻段在大陸是禁用的，如果隨意使用某些通道，有可能被查水表，但通常製作Wifi-AP的公司會禁用該通道才出口到指定國家" class="headerlink" title="頻段的使用定義，雖然由IEEE制定，但某些國家還是有限制，像是802.11ax 有些頻段在大陸是禁用的，如果隨意使用某些通道，有可能被查水表，但通常製作Wifi AP的公司會禁用該通道才出口到指定國家"></a>頻段的使用定義，雖然由IEEE制定，但某些國家還是有限制，像是802.11ax 有些頻段在大陸是禁用的，如果隨意使用某些通道，有可能被查水表，但通常製作Wifi AP的公司會禁用該通道才出口到指定國家</h6><h6 id="因為5G會有很多頻譜，所以5G手機就對應了需要很多射頻、濾波元件，而在手機大小不變的狀況下要塞更多晶片，就需要台積電先進的製程和厲害的IC設計讓IC變更小"><a href="#因為5G會有很多頻譜，所以5G手機就對應了需要很多射頻、濾波元件，而在手機大小不變的狀況下要塞更多晶片，就需要台積電先進的製程和厲害的IC設計讓IC變更小" class="headerlink" title="因為5G會有很多頻譜，所以5G手機就對應了需要很多射頻、濾波元件，而在手機大小不變的狀況下要塞更多晶片，就需要台積電先進的製程和厲害的IC設計讓IC變更小"></a>因為5G會有很多頻譜，所以5G手機就對應了需要很多射頻、濾波元件，而在手機大小不變的狀況下要塞更多晶片，就需要台積電先進的製程和厲害的IC設計讓IC變更小</h6>]]></content>
      
      
      <categories>
          
          <category> 通訊協定系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
            <tag> 協定 </tag>
            
            <tag> ITU </tag>
            
            <tag> 國際電信聯盟 </tag>
            
            <tag> 無線通訊 </tag>
            
            <tag> 有線通訊 </tag>
            
            <tag> CCITT </tag>
            
            <tag> ISO </tag>
            
            <tag> 時間 </tag>
            
            <tag> ISO 31-1 </tag>
            
            <tag> 銫原子 </tag>
            
            <tag> IEEE </tag>
            
            <tag> IEEE802 </tag>
            
            <tag> IEEE802.11 </tag>
            
            <tag> 第六代WiFi </tag>
            
            <tag> WiFi </tag>
            
            <tag> 能階 </tag>
            
            <tag> 4G </tag>
            
            <tag> 5G </tag>
            
            <tag> 2.4G </tag>
            
            <tag> ISM </tag>
            
            <tag> 頻譜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讀書P.01 - 人類簡史</title>
      <link href="/2021/04/02/%E8%AE%80%E6%9B%B8P.01%20-%20%E4%BA%BA%E9%A1%9E%E7%B0%A1%E5%8F%B2/"/>
      <url>/2021/04/02/%E8%AE%80%E6%9B%B8P.01%20-%20%E4%BA%BA%E9%A1%9E%E7%B0%A1%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="人類簡史"><a href="#人類簡史" class="headerlink" title="人類簡史"></a><strong>人類簡史</strong></h1><p>這是一本以色列的歷史學家 尤瓦爾·赫拉利 所寫的書，從宇宙大爆炸開始講述人類歷史的完整故事，以下的紀錄是我自己觀看的心得和整理，有些書上可能沒有提到，主要會以智人的轉變來探討宗教、國家、科學。<br>宇宙的源起(大爆炸)大約出現在135億年前。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/a27vzfs.png" src="/img/loading.gif" class="lazyload" title></a><br>地球大約出現在46億年前。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/6QcsJGa.png" src="/img/loading.gif" class="lazyload" title></a><br>生命大約出現在40億年前。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/KEYlzeK.png" src="/img/loading.gif" class="lazyload" title></a><br>真核生物(具有細胞核的生物)大約出現在15億年前。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/g7FMVDD.png" src="/img/loading.gif" class="lazyload" title></a><br>多細胞生物大約出現在11年前。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/cuABIBg.png" src="/img/loading.gif" class="lazyload" title></a><br>動物、植物大約在3.6億年前登上陸地。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/LLCskzJ.png" src="/img/loading.gif" class="lazyload" title></a><br>恐龍大約出現在2億年前。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/JRgtVqQ.png" src="/img/loading.gif" class="lazyload" title></a><br>猿人大約出現在600萬年前。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/9sjRPae.png" src="/img/loading.gif" class="lazyload" title></a><br>智人大約出現在16萬年前。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/3OwDtEO.jpg" src="/img/loading.gif" class="lazyload" title></a></p><p>而我們現在世界上只有一種人，智人，我們都是智人的一種<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/mKz8iPW.png" src="/img/loading.gif" class="lazyload" title></a><br>但是在10萬~200萬年前，這世界上不只有智人這物種，還有很多物種。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/HjVa9li.png" src="/img/loading.gif" class="lazyload" title></a><br>科學家們根據DNA來分類，就像是你不會把貓和老虎混淆，雖然都是貓科，但是他們卻是不同物種。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/njQPvDe.png" src="/img/loading.gif" class="lazyload" title></a></p><p>他們分別居住在不同地域，有不同的進化特徵和生活習慣，如果沒有意外就會存活到我們這個時代，而我們祖先智人在非洲，於10萬年前第一次走出非洲，但立刻遭到尼安德特人的痛擊並擊退。在7萬年前智人卻能成功走出非洲，對尼安德特人進行了種族滅絕，並且開始征服全世界的人種，成為唯一的人種，很明顯意外發生了。</p><h1 id="人種的誕生："><a href="#人種的誕生：" class="headerlink" title="人種的誕生："></a>人種的誕生：</h1><p>1973年，科學家考古發現一具來自320萬年前的12歲猿人化石，取名為「露西」，該化石各種證據指出，320萬年前的猿人是長距離直立行走的物種，長距離直立行走是奠定人類生存的基石，很少有動物能實現長距離行走，主要形成原因是：</p><p>根據考古資料，原本非洲是個森林密茂、水草豐厚的地域，因為大部分的獵食動物無法爬樹，於是古猿選擇在樹林的樹枝上生活，這是相對安全的選擇，而為了要在樹林間攀爬，演化了擅於爬樹的前肢，古猿們以食用各種水果和小昆蟲為生，古猿為了要收集樹上果實，於是又演化了靈活的雙手，雖然古猿可以在樹林中直立行走，但也只是短距離，沒必要演化出長距離的需求。</p><p>直到某次板塊運動將非洲一分為二，中間分開的地方被稱為「東非大裂谷」，並且也形成一些山脈，而這些山脈的隆起，把非洲西邊吹來的濕潤空氣給阻擋了，導致非洲東部逐漸乾燥，樹林矮化，草原誕生。</p><p>而位於東部的古猿們為了生存，被迫移動到草原生活。當古猿第一次來到草原遇到了很多生存威脅，其中威脅力最高的是草原肉食動物，他們依靠優秀的嗅覺、聽覺、視覺、四肢行動力來捕捉動物進行生存，身為古猿優勢是爬樹，我們有優秀的前肢和靈活的手掌，但是到了草原沒樹爬了，別人都用四肢快速移動，而我們的前肢又不是設計來奔跑的，很明顯我們猿人剛到草原無法適應，於是古猿做出了一些改變：</p><ol><li>為了要盡快得知肉食動物的進攻，才能更大機率逃跑，最直接的方法是讓視線超越草叢，於是古猿們站起來了</li><li>草原的食物貧瘠，古猿們被迫要長距離移動，以利尋找到更多的食物</li><li>原本樹林飲食習慣被迫改為草原飲食習慣，像是吃肉<br>綜合上述三點無法適應的古猿們將被淘汰，適應的古猿發生了一些特殊的改變，改變後的古猿我們稱之為猿人。</li></ol><h2 id="長距離直立行走："><a href="#長距離直立行走：" class="headerlink" title="長距離直立行走："></a>長距離直立行走：</h2><p>因為直立行走了，古猿可以提早發現危險和食物，因此古猿可以吃到高品質的食物(肉)，所以有更多的養分來源，而且還是高品質來源，提供了優秀的進化環境。</p><h2 id="直立行走的影響："><a href="#直立行走的影響：" class="headerlink" title="直立行走的影響："></a>直立行走的影響：</h2><p>我們說過古猿因為直立行走可以吃到肉？為什麼</p><p>科學家們曾經測試過，給四肢行走的猩猩戴上氧氣罩，之後找一個相同體重的直立行走的人做比對，發現同樣的移動距離，猩猩的耗氧量是人的4倍，所以直立行走能夠更有效的長距離移動</p><h2 id="為什麼我們需要長距離移動："><a href="#為什麼我們需要長距離移動：" class="headerlink" title="為什麼我們需要長距離移動："></a>為什麼我們需要長距離移動：</h2><p>上述提到直立行走，讓我們有能力進行長距離移動，但是為什麼我們需要長距離移動，這跟能吃上肉有什麼關係？</p><p>因為古猿剛到草原，飲食習慣改變，需要涉入更多的食物，於是開始吃肉，但是草原動物羚羊哪一個不是超跑等級的怪物，古猿才剛有直立行走的功能，能跑贏他嗎，於是古猿們採用新的捕獵方式：傻呼呼的追著對方跑，雖然跑不贏但也能累死羚羊，根據上面的耗氧實驗，可以知道爬行動物跑得快，但是能量消耗高，更何況當羚羊看到，有個連伏擊都不會直接衝上來想吃自己的白癡，跑了一天一夜還在追，處於驚慌的情況下，更加劇能量的消耗，後來羚羊被累死了，所以狩獵技巧就是累死他後吃上肉。</p><h2 id="體毛的退化："><a href="#體毛的退化：" class="headerlink" title="體毛的退化："></a>體毛的退化：</h2><p>並且我們為了長距離奔跑，我們退化了毛髮。為什麼我們沒有像是熊一樣厚重的體毛，體毛能幫我們抵禦蚊蟲、草叢劃傷、防止曬傷、保護色等等。這麼多的好處，為什麼要捨棄？ 因為我們長距離移動需要優秀的散熱，所以我們退化了體毛，加強了汗腺，保留了頭髮抵禦頭頂的直射陽光，眉毛讓汗水不會影響到我們眼睛。</p><p>獵豹號稱動物界的法拉利，因為沒有散熱系統，所以無法長距離追逐動物，雖然是超跑，但是油量非常少，不然全世界都被獵豹佔領了。</p><h2 id="大腦的升級："><a href="#大腦的升級：" class="headerlink" title="大腦的升級："></a>大腦的升級：</h2><p>上面講了古猿如何獲取高品質的養分，為此付出什麼代價，我們在講一個好處，因為直立行走，可以看得更遠對於平衡的需求更高，人腦就需要變得更聰明更高效，就像是CPU一樣，原本你只要辨別周圍1公里的事物，CPU用AMD做的就堪用，但是現在需要看周圍10公里的事物，這就需要Intel的CPU才能應付，而要使用Intel的CPU你必須擁有更多的金錢(養分)。</p><h6 id="更何況你需要在奔跑中認清周圍，就必須更優秀的處理器，像是移動中的相機，對於畫素的處理就很爛，因為移動中需要非常強大的CPU。"><a href="#更何況你需要在奔跑中認清周圍，就必須更優秀的處理器，像是移動中的相機，對於畫素的處理就很爛，因為移動中需要非常強大的CPU。" class="headerlink" title="更何況你需要在奔跑中認清周圍，就必須更優秀的處理器，像是移動中的相機，對於畫素的處理就很爛，因為移動中需要非常強大的CPU。"></a>更何況你需要在奔跑中認清周圍，就必須更優秀的處理器，像是移動中的相機，對於畫素的處理就很爛，因為移動中需要非常強大的CPU。</h6><h6 id="大腦之所以升級，是因視野的變更需求和平衡感，並且我們有足夠多的養分去升級，所以你可以嘗試閉上眼行走或是保持平衡，你會發現很難走的直、保持的很穩。"><a href="#大腦之所以升級，是因視野的變更需求和平衡感，並且我們有足夠多的養分去升級，所以你可以嘗試閉上眼行走或是保持平衡，你會發現很難走的直、保持的很穩。" class="headerlink" title="大腦之所以升級，是因視野的變更需求和平衡感，並且我們有足夠多的養分去升級，所以你可以嘗試閉上眼行走或是保持平衡，你會發現很難走的直、保持的很穩。"></a>大腦之所以升級，是因視野的變更需求和平衡感，並且我們有足夠多的養分去升級，所以你可以嘗試閉上眼行走或是保持平衡，你會發現很難走的直、保持的很穩。</h6><h2 id="大腦升級的效益："><a href="#大腦升級的效益：" class="headerlink" title="大腦升級的效益："></a>大腦升級的效益：</h2><p>大腦原本是因應視野和平衡感進行升級，但是升級後卻又意外發現有更多的功能，學習，像是你看到一隻羚羊被樹枝刺死，你就可以知道尖銳樹枝可以做為武器，這是其他動物都不會有的意識，並且這些東西可以被模仿，你會了就可以教導別人，形成一個高效的聚落，也因此大腦的提升和直立行走的影響，讓人們可以更有效率的獵捕食物，更容易取得到高品質的營養，就有更多時間與族人相處、交流、繁衍、製作工具。</p><h2 id="為什麼其他動物沒有直立行走？"><a href="#為什麼其他動物沒有直立行走？" class="headerlink" title="為什麼其他動物沒有直立行走？"></a>為什麼其他動物沒有直立行走？</h2><p>因為不需要，雖然猿人因為直立行走提升很多能力，但是對非洲動物來說，主要的威脅還是獵豹那些食肉動物，沒必要演化出針對猿人的功能，更何況猿人是雜食類的，誰說一定要吃肉的，只是肉提供了更多的養分。</p><h1 id="尼安德特人："><a href="#尼安德特人：" class="headerlink" title="尼安德特人："></a>尼安德特人：</h1><p>上述的理論提供了一種人是怎麼從猴子變成人的過程，而要理解為什麼智人能征服全世界人種，我們先從智人的第一個敵人來介紹，根據考古發現：</p><ul><li>尼安德特人的腦子比智人大，更聰明</li><li>尼安德特人的身體比智人強壯，是最高級的獵食者</li><li>尼安德特人的眼睛比智人大，以利在方圓幾公里迅速找到食物<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/1ttdRwW.jpg" src="/img/loading.gif" class="lazyload" title></a></li></ul><p>除了上述條件，其他智人與尼安德特人相差不多，從上面條件可以看出，尼安德特人跟智人的差距是非常大，也難怪智人第一次會走不出非洲，但是什麼原因造成尼安德特人被滅絕呢？</p><p>首先大腦不是越大越好，那只是物種在面對環境演化的工具，就像是身高，長頸鹿如果沒這麼高，那麼地上草食動物太多，長頸鹿的食物就會被別人吃光，相同道理，你有看過100公尺長的長頸鹿嗎，沒有。因為太高了反而吃不到樹葉，就不可能存活到現在被我們所知道。</p><p>大腦也是如此，而且大腦是奢侈品，只占用我們體重的3%，但是卻消耗的能量卻占到全身的25%，也就是說你為了這小東西，付出了25%的能量給他，古猿也是很幸運地具有獲取高品質的養分的技能，才能夠養起這個奢侈品，如果養不活也沒必要演化出，聰明一點但是卻會餓死的物種，又或者說早就有這物種，只是馬上被大自然淘汰了。</p><h1 id="智人的轉變："><a href="#智人的轉變：" class="headerlink" title="智人的轉變："></a>智人的轉變：</h1><p>智人之所以能夠佔領全世界，是因為他們發生了認知革命，某次偶然的基因突變，改變了智人的大腦內部連接方式，讓他們以前所未有的方式來思考，用完全新式的語言來溝通。</p><p>圖</p><p>也就是說智人可以描述沒有見過、聽過、碰過的事物，像是某天智人的家被獵豹盯上，突然冒出個獅子把獵豹殺死吃掉，智人們就會說獅子是我們的守護神、獅子是神明的化身，舉頭三尺有神明等等。而只要提出某個觀點，並且可以讓更多的智人認同，智人就從原本的以家族為單位的群居改為多個部落共同生活。</p><h2 id="群聚的管理："><a href="#群聚的管理：" class="headerlink" title="群聚的管理："></a>群聚的管理：</h2><p>部落共同生活會導致人數非常多，管理上就有困難，但只要他們相信神明的存在，就能一定的限度去制約一些”壞人”，而壞人必定也相信神明存在，不然他們也不會共同生活。</p><h2 id="群聚的好處："><a href="#群聚的好處：" class="headerlink" title="群聚的好處："></a>群聚的好處：</h2><p>智人們擁有這能力後，大家就可以聚集非常多人，只要其中一個愛因斯坦，發明某個科技，就可以快速提升整體水平，並且社交變複雜，大腦就需要更有效的處理，而如果沒有這能力，一個家族就10幾個人，誕生個牛頓在這家族，也頂多10幾個人水平上升，但是其他9萬多個智人水平還是一樣。</p><h2 id="認知革命的差異："><a href="#認知革命的差異：" class="headerlink" title="認知革命的差異："></a>認知革命的差異：</h2><p>尼安德特人因為沒有認知革命，所以只能是小團體的形式生存，像是古猿依靠本能去建立自己的團體，就像是動物園裡的猩猩。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/sgwcge6.png" src="/img/loading.gif" class="lazyload" title></a></p><p>而這正是智人的成功關鍵，根據考古智人與尼安德特人一對一必定失敗，但是上千智人打群架，尼安德特人也就因此沒落，因為尼安德特人沒有有效的合作機制。</p><h2 id="文化："><a href="#文化：" class="headerlink" title="文化："></a>文化：</h2><p>正因為人類有想像不存在的事物，同時也能讓其他人相信，因此統一了全世界，於是開始了各種發展，像是發展了農業讓糧食提供更穩定，於是有了資源去培養所謂的科學家、戰士等等，造就了我們這個世界。</p><p>在這過程中我們虛構了很多事物，這些事物就像是膠水一樣將我們牢牢黏住，讓人類這個群體可以穩定的發展，像是我們相信地獄和天堂的存在，讓互不相識的人能夠互相幫助，我們相信耶穌的存在於是我們參加了十字軍東征。以此形成一個一個的文化。</p><p>但要虛構出不存在的事物，還要讓別人相信，其中最困難的是你要如何讓別人相信，像是我虛構出吃酥皮濃湯把酥皮拿出來出，這樣會遭受到酥皮之神詛咒，於是大家都相信酥皮不能單獨吃於是社會就更團結了？</p><p>明顯要形成一個文化，必須靠得住讓別人相信的理論，其中最成功的就是宗教，</p><h2 id="宗教："><a href="#宗教：" class="headerlink" title="宗教："></a>宗教：</h2><p>今天我們有很多宗教，而宗教是怎麼來的，可以看出是由於智人們可以討論虛構的事物，我們可以討論看不到的事、物、人。人們因為這功能創造出的一個單字，宗教，這裡不討論哪種宗教和上帝的存在等等問題，我們可以根據歷史總結出，宗教是一種能夠穩定社會的產物，聖經、古蘭經、道德經、易經、論語、我的奮鬥等等。</p><p>聖經延伸出很多對於世界萬物的解釋，而貌似這些解釋都好像有道理只是當時科學沒辦法驗證，像是「天動說」說明月球、太陽、星星都是繞著地球轉，所以才會有東昇西落，人們相信聖經而聖經能貌似都能解釋世界萬物，以此為基礎有了穩定的社會。</p><p>我的奮鬥，希特勒闡述了自己的思想 德奧合併、反猶太主義等等，以此讓原本不會有交集的兩個人因同時認同這思想，於是一個人變成一群人，其中思想就像是膠水一樣穩定住這千千萬萬的人民。</p><p>國家，不同的兩個人，會因為自己是台灣人於是一起相互支援奮鬥，皆因為我們相信有國家的存在，但其實國家也是我們幻想的名詞，因為我們都是智人，從DNA上無法知道你是台灣人還是大陸人，只因為我們相信有自己的國家，而國家的形成就是一群人，而這些人之所以會再一起是因為種種文化的影響。</p><h1 id="科學："><a href="#科學：" class="headerlink" title="科學："></a>科學：</h1><p>自從我們從智人統一全世界，之後開始了人類輝煌的發展，農業的發展讓人們有了更多的資源，於是就有了酒、釀酒師、詩人、哲學家、科學家等等，這些專業人員就可以不用花時間去耕田、打獵，只用把心力至於社會發展，科學以此基石誕生。</p><p>隨著科學的誕生，人們發現科學和文化與宗教有所衝突，以下舉個例子：</p><h2 id="伽利略-科學-VS-宗教-："><a href="#伽利略-科學-VS-宗教-：" class="headerlink" title="伽利略 (科學 VS 宗教)："></a>伽利略 (科學 VS 宗教)：</h2><p>是名出生於中世紀的義大利科學家，而當時中世紀的歐洲正處於基督教治國的階段，宗教已經凌駕於王權政府了，聖經中紀載「世界就堅定，不得動搖」，以此為根基就有了「天動說」，當時的神學家們推崇古希臘天文學家托勒密的「地球是宇宙中心」的學說，他們宣稱，宇宙是一個充滿「各種等級的天使和一個套著一個的水晶球」，而靜止不動的地球就居於這些水晶球的中心。</p><p>哥白尼發現其實地球不是宇宙的中心，但是哥白尼的作品沒有廣泛傳播，他的同輩有人嘲笑他，有人譴責他。連宗教改革領袖馬丁·路德都說：「這個蠢材希望顛覆整個天文學體系。但是《聖經》告訴我們，約書亞喝令停止不動的是太陽，而不是地球。」</p><p>然而哥白尼的著作影響了伽利略。</p><p>伽利略使用自製的望遠鏡得到更多的數據，這些數據都支持了「地球不是宇宙中心」的觀點，而因此寫了一本書「關於托勒密和哥白尼兩大世界體系的對話」，這本書在出版前是得到了審查官允許和支持的(當時教宗是伽利略的好朋友)，然而不久教廷就後悔了，人們把這本書是為擁護哥白尼主義的令人信服的論證。這本書顛覆了人們對於聖經的紀載、世界的存在等等，於是教宗決定進行審訊伽利略，伽利略被關進了宗教裁判所的牢獄，並且不准與任何人接觸，長期的牢獄生活早已摧毀了伽利略的健康和鬥志。他最終同意放棄哥白尼學說，從學術上來說，伽利略的生命就此終結。事實上，餘生他都在軟禁中度過，不能外出旅行，一次只能接待幾個客人</p><h2 id="乾隆-VS-洋人下跪-文化-VS-宗教-："><a href="#乾隆-VS-洋人下跪-文化-VS-宗教-：" class="headerlink" title="乾隆 VS 洋人下跪 (文化 VS 宗教) ："></a>乾隆 VS 洋人下跪 (文化 VS 宗教) ：</h2><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/DBJRbPi.png" src="/img/loading.gif" class="lazyload" title></a><br>還記得當初發生了乾隆接待了馬加爾尼使團，但是卻發生了禮儀問題，乾隆認為我是天子，上天的兒子，任何人見到我都需要雙膝跪拜，你一個洋人居然不跪，於是因為禮節不同，西方使者拒絕下跪乾隆大帝，中國錯失發展良機，當初特使團攜帶的先進武器也因此都被丟進圓明園的倉庫，而因為乾隆這舉動導致以後的幾百年中國都被西方列強欺凌。</p><h2 id="思辨："><a href="#思辨：" class="headerlink" title="思辨："></a>思辨：</h2><p>上述講了兩個歷史例子，我們分別從這兩個點開始思辨宗教、文化、科學。</p><p>待續….<br><del>~<br>人們因為宗教於凝聚在一起，凝聚後(國家)更有效的進行分工，就更有效的產生多餘的資源，以此養活一些專業人士(科學家)，隨著科學發展宗教開始被人質疑，我們<br>，但如果我們有時光機的話，阻止了伽利略的打壓、乾隆的下跪堅持，那是不是當今社會會更好呢？答案：不一定。如果我們是清朝人民，從小灌輸到大的概念就是，皇帝就是上天的兒子，那麼洋人居然不用下跪也不會發生什麼天譴，那且不是皇帝不是上天的兒子嗎？那這個社會的穩定度不就被破壞了嗎？</del></p>]]></content>
      
      
      <categories>
          
          <category> 讀書心得系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人類 </tag>
            
            <tag> 尼安德特人 </tag>
            
            <tag> 智人 </tag>
            
            <tag> 大腦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.12 - NodeJS</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.12%20-%20NodeJS/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.12%20-%20NodeJS/</url>
      
        <content type="html"><![CDATA[<h1 id="NodeJS："><a href="#NodeJS：" class="headerlink" title="NodeJS："></a>NodeJS：</h1><ul><li>NodeJS對於後端來說可以當作Server</li><li>NodeJS對於前端來說可以當作開發環境</li></ul><p>首先要解釋NodeJS，我們必須在簡單介紹一下V8引擎，V8除了对JavaScript性能的大幅提升，還提供了”嵌入”的功能，簡單說就是能夠使用JavaScript語言來實現C++功能，其中包含讀取本地文件功能。<br>而NodeJS就是使用V8來實作，對於後端可以當作Server但是此處不討論，此處我們討論很多人使用NodeJS開發初一些特出的工具，而這些工具是什麼？要怎麼下載？要怎麼呼叫？ … 等等一系列問題。</p><h2 id="NVM："><a href="#NVM：" class="headerlink" title="NVM："></a>NVM：</h2><p>首先NodeJS一直改版，所以如果使團隊開發的話我們必須統一使用什麼版本，所以有種工具應運而生NVM。<br>NVM開源庫：<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a><br>NVM Windows版本的Release：<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a><br>使用者可以去NVM Windows版本的Release下載該工具的安裝程式，根據Git Hub說明進行操作：</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/3t5I8FB.png" src="/img/loading.gif" class="lazyload" title></a></p><p>根據團隊規定要使用哪種版本，輸入nvm install 版本號。即可。</p><h2 id="如何初始化和安裝工具："><a href="#如何初始化和安裝工具：" class="headerlink" title="如何初始化和安裝工具："></a>如何初始化和安裝工具：</h2><p>安裝完NodeJS後，NodeJS對於我們前端就是一個開發環境，所以我們先創立任意資料夾，之後於command line 形式輸入 npm init -y<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/pWUEvJ0.png" src="/img/loading.gif" class="lazyload" title></a><br>輸入完後會自動創立一個packeage.json的檔案，該檔案紀載了當前你創立專案的詳細資料。</p><p>那麼NodeJS專案能夠提供給我們什麼幫助？<br>因為NodeJS是個能夠讓JavaScript脫離瀏覽器還能執行的環境，所以很多大老基於NodeJS寫了很好用的工具，這些工具可以說讓前端更容易的運維、部屬，更容易的實現CI/CD，而這些工具要如何下載和使用呢？答案：NPM(熟悉Python的人可以把它當作pip、熟悉C#的人可以把它當作NuGet)。<br>一樣使用command line，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install XXXXX：就可以下載你要的工具，但是通常我們還會增加一些參數。</span><br><span class="line">npm install -d XXXX：代表我下載的工具是局部的，只能在我的專案資料夾工作。</span><br><span class="line">npm install -g XXXX：代表我下載的工具是全域的，能夠在任何資料夾工作。</span><br><span class="line">XXXX就是工具註冊NPM的空間名稱，詳情可以去https:&#x2F;&#x2F;www.npmjs.com&#x2F; 搜尋或是看看什麼工具最多人用</span><br></pre></td></tr></table></figure></div><p>其中 npm install -d 是能夠把你下載的工具紀載到package.json裏頭，所以下次要給別人你的專案時後只用給他，你寫的程式碼 + package.json，不用給他這些工具的下載位置等等。收到的人只要用 npm install 就可以自動把你使用的工具還原到電腦裡。</p><h2 id="如何使用工具："><a href="#如何使用工具：" class="headerlink" title="如何使用工具："></a>如何使用工具：</h2><p>知道如何下載工具後我當然要知道怎麼使用工具，而TypeScript其實也是一種工具，根據官網我們也知道該如何下載他，那我要怎麼讓tsc將TypeScript轉換成JavaScript呢？<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/WgrltXC.png" src="/img/loading.gif" class="lazyload" title></a><br>上圖這是package.json的內容，其中script裡的成員你可以把它當作一個任務，一個task，在預設中有個任務叫做test，這個任務是去呼叫echo 之後丟入一些文字，所以可以知道這個test的任務就是輸出”Error： no test …”在畫面上，所以我們也可以新增自己的任務。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot; : &quot;tsc&quot;,</span><br><span class="line">&quot;watch&quot; : &quot;tsc -w&quot;</span><br></pre></td></tr></table></figure></div><p>上述功能就是新增一個任務叫做<br>build：執行一次tsc，而tsc會根據tsConfig.json去選擇要編譯的TS檔案在哪<br>watch：偵測tsConfig.json紀載的要編譯TS檔案，如果其中一個檔案被修改並儲存就會自動幫你編譯，你就不用修改-&gt;儲存-&gt;tsc 一次，因為你按下儲存瞬間tsc就會自動執行了。<br>好了我們定義了任務，而根據不同的任務會呼叫不同的tsc功能，那怎麼呼叫任務呢？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></div><p>以上就是如何透過NodeJS去需叫工具的使用，那麼這邊推薦一些好用的工具。</p><h1 id="Bable："><a href="#Bable：" class="headerlink" title="Bable："></a>Bable：</h1><p>此處提供一些非常好用的工具，Bable就是其中一個，JavaScript有很多ES版本，每次改版都會推出非常好用和簡潔的API使用方法，但是如果今天我使用ES6版本來開發，很多瀏覽器都支援，但要是使用者用IE這個不支援ES6的瀏覽器造訪你的網頁，不就看不了嗎，於是Bable能夠幫你把ES6版本轉換成IE能看得懂的版本，故與聖經中的巴別塔同名。 詳細使用教學以後會補充。</p><h1 id="Uglify"><a href="#Uglify" class="headerlink" title="Uglify:"></a>Uglify:</h1><p>詳細使用教學以後會補充。</p><h1 id="TypeScript-NPM-："><a href="#TypeScript-NPM-：" class="headerlink" title="TypeScript(NPM) ："></a>TypeScript(NPM) ：</h1><p>今天因為NodeJS的發明，以至於我們可以直接使用npm 下載tsc編譯器，就不用去官網gitHub下載。 在安裝時後可以選擇npm i -g typescript，將它安裝成全域的工具，這樣你在任何地方寫的TS都可以直接被編譯。 詳細使用教學以後會補充。</p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> V8 </tag>
            
            <tag> TypeScript </tag>
            
            <tag> NodeJS </tag>
            
            <tag> NVM </tag>
            
            <tag> npm </tag>
            
            <tag> packeage.json </tag>
            
            <tag> Bable </tag>
            
            <tag> Uglify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.13 - WebPack</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.13%20-%20WebPack/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.13%20-%20WebPack/</url>
      
        <content type="html"><![CDATA[<h1 id="WebPack："><a href="#WebPack：" class="headerlink" title="WebPack："></a>WebPack：</h1><p>此處提供一些非常好用的工具，WebPack就是其中一個，他是前端自動化開發使用的工具。<br>對於早期的前端(NodeJS以前)來說，瀏覽器就只能單純識別3大元素(CSS、HTML、JavaScript)，但是NodeJS打破這規則，現在的前端使用了很多工具像是上述的範例，但是前端工具是新的技術，這些工具很多都是基於NodeJS的根本無法作業在瀏覽器，所以對瀏覽器是無法直接識別，那我如果要呼叫難道要</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">執行tsc</span><br><span class="line">執行bable</span><br><span class="line">執行gulp</span><br><span class="line">執行....</span><br></pre></td></tr></table></figure></div><p>明顯很愚蠢，每次我編譯一次看結果，都要輸入好幾行指令來產生，所以有了WebPack負責把這些東西自動轉換成瀏覽器能夠識別的產物，並且還能夠打包一起。<br>其次現在前端使用了很多庫，就像是jQuery一樣，使用別人的函數庫能夠減少自己德開發時間，所以有時候你可能引入了10幾個函數庫，每個函數庫都是一個JS檔案。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;jQuery&quot;&gt; &lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;物理庫&quot;&gt; &lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;Tween&quot;&gt; &lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;特效庫&quot;&gt; &lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;廣告庫&quot;&gt; &lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;Index.js&quot;&gt; &lt;&#x2F;script&gt;</span><br><span class="line">....etc</span><br></pre></td></tr></table></figure></div><p>這樣會有一個問題，script標籤進行下載的會是非同步的操作，假設index.js使用到了jQuery，但是非同步關係，index.js下載好後發現找不到jQuery，於是就抱錯了，因為jQuery檔案比較大還在下載中。所以WebPack還能打包再一起，保證不會發生以上問題。<br>所以可以知道WebPAck主要功能就是幫你處理以上兩個問題，所以此處我們開始介紹怎麼使用WebPack解決該問題。</p><h2 id="TypeScript轉JavaScript："><a href="#TypeScript轉JavaScript：" class="headerlink" title="TypeScript轉JavaScript："></a>TypeScript轉JavaScript：</h2><p>首先我們主程式的入口叫做Main，而Main使用了display這個庫，詳細引用關係如下：</p><p>Main.ts：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import displayObj from &quot;.&#x2F;display&quot;; &#x2F;&#x2F; 引入了display.ts，之後創立一個變數&quot;displayObj&quot;存取他。</span><br><span class="line">import &#123;titel&#125; from &quot;.&#x2F;display&quot;; &#x2F;&#x2F; 引入display.ts的titel變數，並且是直接調用，不用創立變數儲存。</span><br><span class="line"></span><br><span class="line">var temp: number &#x3D; 20;</span><br><span class="line">var msg: string &#x3D; &quot;Heldlo&quot;;</span><br><span class="line">displayObj.showMsg(msg + temp); &#x2F;&#x2F; 透過變數displayObj呼叫 display.ts 導出的showMsg函數</span><br><span class="line">displayObj.test();</span><br></pre></td></tr></table></figure></div><p>display.ts：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var titel: String &#x3D; &quot;[display.ts] &quot;; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 創立一個只能儲存函數的變數叫做showMsg</span><br><span class="line">&#x2F;&#x2F; 該變數存儲的是由ES6的箭頭函數語法所創立的函數</span><br><span class="line">&#x2F;&#x2F; 該函數需要傳入一個string的參數，該參數在函數裡名稱為 msg</span><br><span class="line">var showMsg:Function &#x3D; (msg: string) &#x3D;&gt; &#123;  </span><br><span class="line">    console.warn(titel + msg);</span><br><span class="line">    console.log(titel + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const aa:Array&lt;string&gt;  &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; &#x2F;&#x2F; 創立一個字串陣列</span><br><span class="line">&#x2F;&#x2F; 創立一個只能儲存函數的變數叫做test</span><br><span class="line">&#x2F;&#x2F; 該變數存儲的是由ES6的箭頭函數語法所創立的函數</span><br><span class="line">&#x2F;&#x2F; 該函數不需要傳入任何參數</span><br><span class="line">&#x2F;&#x2F; 該函數的實作內容是由ES5的Array的Map函數所構成</span><br><span class="line">&#x2F;&#x2F; Array Map的函數時做內容是 把這個Array每個items 顯示出來。</span><br><span class="line">var test:Function &#x3D; () &#x3D;&gt; aa.map(function (obj) &#123; console.log(obj) &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 有什麼函數或是變數是可以給別人使用的，此處就將它塞入導出的列表內</span><br><span class="line">&#x2F;&#x2F; default 代表導出後，導入的使用者必須用一個變數儲存，之後透過該變數去操作導出的成員</span><br><span class="line">export default &#123; </span><br><span class="line">    showMsg, &#x2F;&#x2F; 導出showMsg變數</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 未使用 default導出，導入的使用者無須創立變數去儲存，如要使用就必須取同名參數，代表直接讀取</span><br><span class="line">export &#123;titel,aa&#125;;</span><br></pre></td></tr></table></figure></div><p>首先呢，這是一份ts檔案，沒有人能認得，所以參考 如何使用工具，進行以下前置動作把TS轉成JS檔案：</p><ol><li><p>創立資料夾，隨便取但不能中文：</p></li><li><p>使用Cammand Line 輸入 npm init -y：</p></li><li><p>創立子資料夾名為src，把Main.ts和display.ts 丟到該資料夾</p></li><li><p>使用Cammand Line 輸入 npm i -g typescript：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/0TFr78g.png" src="/img/loading.gif" class="lazyload" title></a></p></li><li><p>使用Cammand Line 輸入 tsc –init：</p></li><li><p>修改tsconfig.json內容：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/pXf8bL7.png" src="/img/loading.gif" class="lazyload" title></a></p></li><li><p>使用Cammand Line 輸入 tsc 進行編譯：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/UMZS5O8.png" src="/img/loading.gif" class="lazyload" title></a></p></li></ol><h6 id="此處把tsc安裝成全域的，然後直接透過工具的呼叫方法來執行，所以可以不用寫-npm-run-之類的內容，要寫也是可以只是我懶。"><a href="#此處把tsc安裝成全域的，然後直接透過工具的呼叫方法來執行，所以可以不用寫-npm-run-之類的內容，要寫也是可以只是我懶。" class="headerlink" title="此處把tsc安裝成全域的，然後直接透過工具的呼叫方法來執行，所以可以不用寫 npm run 之類的內容，要寫也是可以只是我懶。"></a>此處把tsc安裝成全域的，然後直接透過工具的呼叫方法來執行，所以可以不用寫 npm run 之類的內容，要寫也是可以只是我懶。</h6><h2 id="WebPack的合併使用："><a href="#WebPack的合併使用：" class="headerlink" title="WebPack的合併使用："></a>WebPack的合併使用：</h2><p>上述操作完成後會有個資料夾叫做bin-debug，裡面就是TS轉成JS的檔案，而現在我們要把它們整合，就必須使用WebPack。<br>首先根據官方網站說明必須要有個檔案叫做webpack.config.js，其檔案裡面應該要寫這些配置。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/JWCuKDd.png" src="/img/loading.gif" class="lazyload" title></a><br>這些配置主要就是敘述：程式的入口是entry，進行合併後把檔案放到path(如果沒有預先創資料夾會自動創)，之後把合併檔案取名為 filename。<br>所以首先我們要修改entry，將它改成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: &#39;.&#x2F;bin-debug&#x2F;Main.js&#39;,</span><br></pre></td></tr></table></figure></div><p>之後filename通常建議改為跟原檔案同名+bundle，也就是</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename: &#39;Main.bundle.js&#39;</span><br></pre></td></tr></table></figure></div><p>這些配置輸入完成後，我們就可以新增任務在package.json</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot; : webpack</span><br></pre></td></tr></table></figure></div><p>只要輸入npm run build就可以執行了，WebPack就會自動判斷Main.js系列文件到底用了什麼檔案，都會自動打包成一個JS。</p><h2 id="Loader："><a href="#Loader：" class="headerlink" title="Loader："></a>Loader：</h2><p>而在上述Case在使用之前還要自己打tsc進行轉換，這不是很麻煩嗎，所以WebPack第二個功能是能夠整合工具進入流程，而這邊用兩個工具來模擬前端現在開發的數個工具。</p><h3 id="TypeScript-Loader："><a href="#TypeScript-Loader：" class="headerlink" title="TypeScript Loader："></a>TypeScript Loader：</h3><p>要將tsc加入WebPack的話你需要下載一個工具，叫做ts-loader，可以參考該工具的GitHub說明：<a href="https://github.com/TypeStrong/ts-loader" target="_blank" rel="noopener">https://github.com/TypeStrong/ts-loader</a><br>在官網中敘述了，如果要將ts-loader加入WebPack，必須加入這些Webpack.Config設定。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/dEC2ffN.png" src="/img/loading.gif" class="lazyload" title></a><br>設定完還必須要加入tsconfig.json 還必須要加入sourceMap 選項<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/aAuSJrq.png" src="/img/loading.gif" class="lazyload" title></a></p><p>這些都完成後你的WebPack.Config應該長這樣：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/D4T3jC5.png" src="/img/loading.gif" class="lazyload" title></a></p><h3 id="Babel-Loader："><a href="#Babel-Loader：" class="headerlink" title="Babel Loader："></a>Babel Loader：</h3><p>上面的教學講了很多Babel的用途和好處，所以Babel也算是必要的工具，可以參考該工具的GitHub說明：<a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">https://github.com/babel/babel-loader</a><br>首先是要下載很多工具。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D babel-loader @babel&#x2F;core @babel&#x2F;preset-env webpack</span><br></pre></td></tr></table></figure></div><p>之後如果要將這個工具加入WebPack，必須加入這些WebPack.Config設定。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/8eVev4o.png" src="/img/loading.gif" class="lazyload" title></a><br>而如果你要設定Babel的選項的話，你可以採用這種加入方式。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/TNOAG58.png" src="/img/loading.gif" class="lazyload" title></a><br>那今天我們要Babael將 箭頭函數 轉換成標準化的函數，可以從 options 點進去看說明。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/jBMBR9j.png" src="/img/loading.gif" class="lazyload" title></a><br>所以我們Babel Loader 的WebPack.Config設定應該是長這樣：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/Uuw0r5A.png" src="/img/loading.gif" class="lazyload" title></a></p><h2 id="Plugin："><a href="#Plugin：" class="headerlink" title="Plugin："></a>Plugin：</h2><p>上述是一種WebPack引入工具的方式，加入Loader，但是WebPack的強大不是沒有原因，因為他本身就內建很熱門的工具，而要使用內建的話就要用Plugin方式呼叫。<br>首先有什麼很夯的工具被WebPack整合過呢？請參考WebPack官網：<a href="https://webpack.js.org/plugins" target="_blank" rel="noopener">https://webpack.js.org/plugins</a><br>那今天我們用另外一個工具來示範，就是另一個好用的Uglifyjs工具。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/UYihfKW.png" src="/img/loading.gif" class="lazyload" title></a><br>根據官方網站說明，你應該要下載該工具：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure></div><p>之後WebPack必須加入這些配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const UglifyJsPlugin &#x3D; require(&#39;uglifyjs-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [new UglifyJsPlugin()],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>而該工具也有選項可以開啟，詳細可以去官網看或是中文翻譯的文檔： <a href="https://github.com/LiPinghai/UglifyJSDocCN" target="_blank" rel="noopener">https://github.com/LiPinghai/UglifyJSDocCN</a><br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/5fTFEEb.png" src="/img/loading.gif" class="lazyload" title></a></p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/0YeOcLH.png" src="/img/loading.gif" class="lazyload" title></a></p><p>而今天我們使用 compress 的 pure_funcs，該功能很好用，能夠幫你把某一個函數剃除，像是我正式版本我不需要console.log，所以我可以利用該功能把console.log進行剔除，或是把我自己的測試函數剃除。<br>選定功能後我們可以在WebPack的官網查到，如何使用該選項</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/TbQlxLr.png" src="/img/loading.gif" class="lazyload" title></a></p><p>所以我們 Uglifyjs Plugin 的WebPack.Config設定應該長這樣：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/K9FUsDh.png" src="/img/loading.gif" class="lazyload" title></a></p><p>而總和上述三個工具的WebPack設定應該長這樣：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/mr4UOhR.png" src="/img/loading.gif" class="lazyload" title></a></p><p>之後我們執行webpack的任務就可以一條龍的處理這三個工具。</p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> NodeJS </tag>
            
            <tag> npm </tag>
            
            <tag> packeage.json </tag>
            
            <tag> Bable </tag>
            
            <tag> Uglify </tag>
            
            <tag> WebPack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.09 - 同步和異步</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.09%20-%20%E5%90%8C%E6%AD%A5%E5%92%8C%E7%95%B0%E6%AD%A5/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.09%20-%20%E5%90%8C%E6%AD%A5%E5%92%8C%E7%95%B0%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="同步和異步："><a href="#同步和異步：" class="headerlink" title="同步和異步："></a>同步和異步：</h1><p>上回我們講了網頁中的下載是如何實施，而其中有個關鍵字異步，我們這邊就進行解釋同步和異步是什麼？用最簡單和粗糙的說法：<br>假設今天你要打電話問書局老闆說「人類簡史」賣光了沒：</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/ylgccQg.png" src="/img/loading.gif" class="lazyload" title></a></p><p>同步：老闆會說等一下我去找找，你就拿著電話筒等了1小時，之後老闆說賣光了。<br>異步：老闆會說等一下我去找找，有結果的話我再打給你A號碼的手機，沒結果的話我再打給你B號碼的手機，之後你把電話掛掉，一小時候老闆打電話給你A電話，你就知道結果了</p><p>以上就是同步和異步的概念，這兩種概念在程式語言佔據很重要的一部分，想想如果我是要下載1GB的檔案，沒有異步的話，你就不能邊看影片邊下載，而程式語言預設都是同步的，所以此處不介紹同步，那麼異部我們用JavaScript來當作範例，await/async是撰寫異步的寫法，是基於Promise的寫法，所以在撰寫異步範例之前，我們需要知道那麼Promise是什麼？</p><h2 id="Promise："><a href="#Promise：" class="headerlink" title="Promise："></a>Promise：</h2><p>今天要談異步操作，那我們看上述書局異步Case，Promise 就是老闆承諾有結果會通知你A電話，沒結果就通知B電話，這是老闆給你的方案。當先前承諾的工作完成時，就來通知我們「工作完成了！來進行下一步的任務吧」，這就是Promise的功能之一「循序執行」，而根據通知結果，有結果(Yes or No)或是沒結果(老闆在找的過程中被暗殺了)，那這兩種方案在程式碼都可以用對應的函數來表達，所以使用Promise時候可以傳入兩個函數，這兩個函數分別代表有結果就執行第一個，沒結果就執行第二個，當然也可以只傳一個函數，以下我們用傳兩個函數的當作範例。</p><h3 id="Promise範例-循序執行範例："><a href="#Promise範例-循序執行範例：" class="headerlink" title="Promise範例 循序執行範例："></a>Promise範例 循序執行範例：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;我：老闆請幫我找一下，「人類簡史」這本書&quot;)</span><br><span class="line">console.log(&quot;老闆：好的，有結果的話我會通知第一個電話答錄機，沒結果我會通知第二個電話答錄機，那麼再麻煩你給我這兩個電話答錄機的名字&quot;)</span><br><span class="line">console.log(&quot;我：好，我現在去找這兩個電話答錄機&quot;);</span><br><span class="line"></span><br><span class="line">function Sucess (strAns) &#123;console.log(&quot;您好Lucas，這是第一台答錄機，您有一則留言：&quot; + strAns)&#125;</span><br><span class="line">function Fail (strAns) &#123;console.log(&quot;您好Lucas，這是第二台答錄機，您有一則留言：&quot; + strAns)&#125;</span><br><span class="line"></span><br><span class="line">console.log(&quot;我：我處理好了，第一個叫做 Sucess ，第二個叫做 Fail。那再麻煩老闆嚕&quot;)</span><br><span class="line">console.log(&quot;老闆：好，我現在就去準備，找到後會再透過這兩個其中一個來通知你。&quot;)</span><br><span class="line"></span><br><span class="line">console.log(&quot;此時老闆開始準備找書，於是老闆開始找書的前置動作，生成剛剛的承諾，Promise&quot;);</span><br><span class="line"></span><br><span class="line">function FindBookProcess() (resolve, reject) &#123; &#x2F;&#x2F; resolve 就是有結果函數。 reject 就是沒結果函數</span><br><span class="line">  setTimeout(function() &#123;  &#x2F;&#x2F; 使用延遲N毫秒後做某件事情的函數，來模擬老闆找書花的時間</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F; doSomething() 執行找書動作，如果這中途發生意外就會跳到Catch，如果沒有意外就會掉到下面一行</span><br><span class="line">         resolve(&quot;同學同學，我有結果了，Yes I Do 我找到了，你聽到這則留言後就可以來找我了&quot;); &#x2F;&#x2F; 老闆有結果後會執行函數並傳入&quot;他想說的話&quot; </span><br><span class="line">    &#125;</span><br><span class="line">    catch(e)</span><br><span class="line">    &#123;</span><br><span class="line">        reject(&quot;同學同學，我發生意外了，剛剛我老婆跟我離婚了，書局被法拍了，我不知道你要的書有沒有在裡面&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 10000); &#x2F;&#x2F; 我們假設老闆花了10秒(10000毫秒)找書</span><br><span class="line">&#125;</span><br><span class="line">const promise1 &#x3D; new Promise(FindBookProcess);</span><br><span class="line"></span><br><span class="line">console.log(&quot;老闆OS：剛剛同學說第一個叫做Sucess，第二個叫做Fail，我記下了，這樣前置動作都完成&quot;)</span><br><span class="line">promise1.then(Sucess , Fail);</span><br><span class="line">console.log(&quot;老闆OS：好從現在開始，我開始找拉&quot;);</span><br></pre></td></tr></table></figure></div><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/Uniebnt.png" src="/img/loading.gif" class="lazyload" title></a></p><p>在上述的案例，老闆採用有結果就通知Sucess，至於結果有可能是 Yes or No，沒結果就通知Fail。那麼我可不可有結果才通知，沒結果就不通知？這也是可以的 promise1.then(Sucess); 就可以。<br>而當我收到通知後我就必須去老闆的店，所以還可以這樣寫<br>promise1.then(Sucess).then(拿錢包).then(搭捷運).then(到老闆的店).then(按電鈴).then…etc ; 這就是循序執行的Promise運用</p><h3 id="Promise範例-併發執行範例："><a href="#Promise範例-併發執行範例：" class="headerlink" title="Promise範例 併發執行範例："></a>Promise範例 併發執行範例：</h3><p>在上述的Case，你問老闆 -&gt; 老闆找 -&gt; 老闆的回應，這是一個循序程序，那麼如果今天情況是：<br>你問老闆 -&gt; 老闆問同行A、B、C -&gt; 老闆自己沒有 但是同行A、B、C還沒有結果 -&gt; 老闆等同行A、B、C回應 -&gt;  都有回應，通知你結果<br>很明顯情況變複雜了，因為此時有4個人幫你找，並且就算其中一個人有你還是必須等其他人的回應，因為你必須知道最近的書局在哪邊，這種Case會變得複雜一點，你可能需要一個計數器算當前回報的人有幾個，如果回報的人數是4個就代表有結果了。</p><p>但其實不用這麼麻煩，只要Promise有提供一個便利的方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function sucess (所有的老闆回應) &#123; </span><br><span class="line">    console.log(&quot;您好Lucas，這是第一台答錄機，您有&quot; +所有的老闆回應.length + &quot;則留言：&quot;)</span><br><span class="line">    for(var i &#x3D; 0 ; i &lt; 所有的老闆回應.length ; i++) </span><br><span class="line">        console.log(&quot;這是第&quot; + i +&quot;個老闆的留言：&quot; + 所有的老闆回應[i])</span><br><span class="line">&#125;; &#x2F;&#x2F; 輸出所有老闆的回應訊息</span><br><span class="line"></span><br><span class="line">function sucess_one (最快老闆的回應) &#123;console.log(&quot;您好Lucas，這是第一台答錄機，您有一則留言：&quot; + strAns)&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const promise老闆 &#x3D; new Promise(.... 請參考上個範例這邊不重新打了);</span><br><span class="line">const promise老闆A &#x3D; new Promise(.... 請參考上個範例這邊不重新打了);</span><br><span class="line">const promise老闆B &#x3D; new Promise(.... 請參考上個範例這邊不重新打了);</span><br><span class="line">const promise老闆C &#x3D; new Promise(.... 請參考上個範例這邊不重新打了);</span><br><span class="line"></span><br><span class="line">Promise.all([promise老闆, promise老闆A,promise老闆B,promise老闆C]).then(success); &#x2F;&#x2F; 所有老闆的回應都結束，就會呼叫success函數</span><br><span class="line">&#x2F;&#x2F; Promise.race([promise老闆, promise老闆A,promise老闆B,promise老闆C]).then(sucess_one); &#x2F;&#x2F; 四個當中誰最先回應，就執行Sucee_one函數，此處就不補充文字說明了，因為顯而易見</span><br></pre></td></tr></table></figure></div><h6 id="還有很多用途，這邊不舉例，詳情請看：https-developer-mozilla-org-zh-TW-docs-Web-JavaScript-Reference-Global-Objects-Promise"><a href="#還有很多用途，這邊不舉例，詳情請看：https-developer-mozilla-org-zh-TW-docs-Web-JavaScript-Reference-Global-Objects-Promise" class="headerlink" title="還有很多用途，這邊不舉例，詳情請看：https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise"></a>還有很多用途，這邊不舉例，詳情請看：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></h6><h3 id="Promise範例-錯誤處理範例："><a href="#Promise範例-錯誤處理範例：" class="headerlink" title="Promise範例 錯誤處理範例："></a>Promise範例 錯誤處理範例：</h3><p>Promise可以併發執行 加上 循序執行 像是： Promise.all([promise老闆, promise老闆A,promise老闆B,promise老闆C]).then(sucess).then(拿錢包).then(搭捷運).then(到老闆的店).then(按電鈴);<br>很明顯會執行到很多函數，複雜度提高很多，所以我們可以加上Catch進行捕捉錯誤。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([promise老闆, promise老闆A,promise老闆B,promise老闆C]).then(sucess).then(拿錢包).then(搭捷運).catch(發生意外叫我弟幫我拿)</span><br></pre></td></tr></table></figure></div><h2 id="Await-Async："><a href="#Await-Async：" class="headerlink" title="Await/Async："></a>Await/Async：</h2><p>上述的程式碼我們知道如何撰寫異步的JS程式碼，很明顯如果要實現 併發執行 + 循序執行，這樣程式碼會很醜很難Debug，就連我自己也懶得寫所以在範例中寫虛擬碼，Promis是屬於ES6時代的產物，但隨著時代演進尤其是Node.js，人們需要更便利的異步處理，於是在ES7加入Await/Async。<br>首先它的誕生是為了讓Promise的可讀性提高，並且更靈活方便的使用異步，所以你如果要函數裡的某一行使用await，就必須在該函數加上 async 的修飾詞，之後就可以使用Await，來讓程式碼變得好看點。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function FindBookProcess() (resolve) &#123; </span><br><span class="line">  setTimeout(function () &#123; return resolve(&quot;同學同學，我有結果了，Yes I Do 我找到了，你聽到這則留言後就可以來找我了&quot;); &#125;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function Shopkeeper_FindBook(BookName) &#123;</span><br><span class="line">    return new Promise(FindBookProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function Main () &#123;</span><br><span class="line">    var res &#x3D; await Shopkeeper_FindBook(&quot;人類簡史&quot;); &#x2F;&#x2F; res &#x3D; &quot;同學同學，我有結果了，Yes I Do 我找到了，你聽到這則留言後就可以來找我了&quot;</span><br><span class="line">    if (res.search(&quot;Yes I Do&quot;) !&#x3D; -1) &#123; &#x2F;&#x2F; 如果老闆有找到的話</span><br><span class="line">        await TakeMoney(); &#x2F;&#x2F; 此處不寫函數了，因為我懶惰</span><br><span class="line">        await GoToMRT();</span><br><span class="line">        await KnockDoor();</span><br><span class="line">        var Book &#x3D; await GetBook();</span><br><span class="line">        console.log(&quot;當前拿到書了，書本內容 &#x3D; &quot; + Book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Main():</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 同步 </tag>
            
            <tag> 異步 </tag>
            
            <tag> Promise </tag>
            
            <tag> Await </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.10 - Scope</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.10%20-%20Scope/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.10%20-%20Scope/</url>
      
        <content type="html"><![CDATA[<h1 id="Scope："><a href="#Scope：" class="headerlink" title="Scope："></a>Scope：</h1><p>接下來我們來看在JavaScripe裡 Scope 問題，JavaScript中Scope 是個必修的問題，在開發中一定會遇到的問題，首先介紹this：</p><h2 id="this："><a href="#this：" class="headerlink" title="this："></a>this：</h2><p>首先我們回到C系列，今天我要讓我的全域變數snm = 函數傳入的一個數字參數，函數的參數叫做sum，請問我該如何處理？ 答案：使用this。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    private int sum &#x3D; 20;</span><br><span class="line">    private void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        test(10);</span><br><span class="line">    &#125;</span><br><span class="line">    private void test(int sum)</span><br><span class="line">    &#123;</span><br><span class="line">        this.sum &#x3D; sum;</span><br><span class="line">        Console.WriteLine(this.sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上述可以得知this功能是指定我現在的作用域來源區域，以此Case是代表 Program Class。</p><p>在JavaScript中，因為它是由引擎所解釋，在瀏覽器執行環境中，一個分頁內所有JavaScript的操作都是在一個物件內執行，我們稱這個為 window，他是這個分頁的root點，並且所有的JavaScript 的API都是放在這個物件內，根據環境不同在瀏覽器內叫做window，而在NodeJS內稱為global。以下我們假定runtime在瀏覽器。</p><p>而JavaScript中，沒有上層物件的話，this 就是指 window，舉例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function tellMeIsInWindow() </span><br><span class="line">&#123;</span><br><span class="line">    var msg &#x3D; this &#x3D;&#x3D; window ?  &quot;Yes&quot; : &quot;No&quot; ;</span><br><span class="line">    console.log(&quot;當前作用域是否在Window內 &#x3D; &quot; + msg);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function showTemp()</span><br><span class="line">&#123;</span><br><span class="line">    console.log(&quot;當前this的temp &#x3D; &quot; + this.temp);</span><br><span class="line">    console.log(&quot;當前window的temp &#x3D; &quot; + window.temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var temp &#x3D; 20;</span><br><span class="line">tellMeIsInWindow(); &#x2F;&#x2F; 會輸出 Yes</span><br><span class="line">showTemp(); &#x2F;&#x2F; 會輸出20</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -----------開始測試有上層物件的情況----------</span><br><span class="line">console.log(&quot;------Start Obj Test------&quot;)</span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.temp &#x3D; 50;</span><br><span class="line">obj.obj_TellMe &#x3D; tellMeIsInWindow;</span><br><span class="line">obj.obj_showTemp &#x3D; showTemp;</span><br><span class="line"></span><br><span class="line">obj.obj_TellMe();</span><br><span class="line">obj.obj_showTemp();</span><br></pre></td></tr></table></figure></div><p>以上程式碼可以按F12貼在於Console頁面的輸入欄執行，就可以看到結果長這樣：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/xbEllv6.png" src="/img/loading.gif" class="lazyload" title></a></p><p>所以我們釐清JavaScript的this操作規則：在沒有上層物件內 this == window，而在有上層物件內this == 上層物件，this 是相對的不是絕對的。</p><h2 id="this-操作："><a href="#this-操作：" class="headerlink" title="this 操作："></a>this 操作：</h2><p>這邊我們用更多的操作來說明this的操作情境：</p><h3 id="1-物件的屬性物件的函式："><a href="#1-物件的屬性物件的函式：" class="headerlink" title="1. 物件的屬性物件的函式："></a>1. 物件的屬性物件的函式：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var player &#x3D; &#123;</span><br><span class="line">  name: &#39;OneJar&#39;,</span><br><span class="line">  f: getName,</span><br><span class="line">  pet: &#123;</span><br><span class="line">    name: &#39;Totoro&#39;,</span><br><span class="line">    f: getName,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(player.f());      &#x2F;&#x2F; &quot;OneJar&quot;</span><br><span class="line">console.log(player.pet.f());  &#x2F;&#x2F; &quot;Totoro&quot;</span><br></pre></td></tr></table></figure></div><p>分析：</p><ul><li>輸出OneJar 因為上層物件是 player，所以輸出對象是player的name</li><li>輸出Totoro 因為上層物件是 pet ，而player則是他的上上層，所以根據規則應該是輸出 Totoro</li></ul><h3 id="2-內部函數："><a href="#2-內部函數：" class="headerlink" title="2. 內部函數："></a>2. 內部函數：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    x: 20,</span><br><span class="line">    f: function()&#123;</span><br><span class="line">        console.log(&#39;Output 1: &#39;, this.x);</span><br><span class="line">        var foo &#x3D; function()&#123; console.log(&#39;Output 2: &#39;, this.x); &#125;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.f();</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output 1:  20</span><br><span class="line">Output 2:  10</span><br></pre></td></tr></table></figure></div><p>分析：</p><ul><li>輸出20 因為上層物件是 obj，所以輸出對象是 obj.x</li><li>輸出10 因為它是由obj的f函數所呼叫，所以他沒有上層物件，這時後就會是window，就是10</li></ul><h3 id="3-HTML-事件處理："><a href="#3-HTML-事件處理：" class="headerlink" title="3. HTML 事件處理："></a>3. HTML 事件處理：</h3><p>onclick 裡的 this，指的就是 button 元素本身</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick&#x3D;&quot;console.log(this);&quot;&gt;</span><br><span class="line">     Click to Remove Me!</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></div><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/9Pe05X0.png" src="/img/loading.gif" class="lazyload" title></a></p><p>但是如果是<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/PAcqbUo.png" src="/img/loading.gif" class="lazyload" title></a><br>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure></div><p>其實就是 內部函數 的變形，點下時後執行onclick，onclike又執行temp函數，所以就是內部函數。</p><h3 id="4-bind方法："><a href="#4-bind方法：" class="headerlink" title="4. bind方法："></a>4. bind方法：</h3><p>ES5 導入了 Function.prototype.bind，可以為一個函數進行綁定參數，並且無法覆蓋已綁定的物件，只能進行擴充</p><ul><li>bind的第一個參數是綁定該函數的擁有物件(擁有者)。</li><li>bind的第二個參數是綁定該函數的第一個參數。</li><li>bind的第三個參數是綁定該函數的第二個參數。</li></ul><p>換句話說，無論新的函數物件怎麼被呼叫，只要函數被bind一次，其函數內的 this 都會是當初綁定的那個擁有者物件。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var getFullName &#x3D; function(lastName) &#123;</span><br><span class="line">    return this.firstName + &quot; &quot; + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var firstName &#x3D; &quot;One&quot;</span><br><span class="line">var lastName &#x3D; &quot;Jar&quot;;</span><br><span class="line"></span><br><span class="line">var introIronMan &#x3D; getFullName.bind( &#123; firstName: &quot;Tony&quot; &#125; , &quot;Stark&quot; );</span><br><span class="line">var introCaptainAmerica &#x3D; getFullName.bind( &#123; firstName: &quot;Steven&quot; &#125; , &quot;Rogers&quot; );</span><br><span class="line">var introThanos &#x3D; introIronMan.bind( &#123; firstName: &quot;IDonT&quot; &#125; , &quot;Know&quot; );</span><br><span class="line"></span><br><span class="line">console.log(getFullName(lastName));   &#x2F;&#x2F; &quot;One Jar&quot;</span><br><span class="line">console.log(introIronMan());          &#x2F;&#x2F; &quot;Tony Stark&quot;</span><br><span class="line">console.log(introCaptainAmerica());   &#x2F;&#x2F; &quot;Steven Rogers&quot;</span><br><span class="line">console.log(introThanos());           &#x2F;&#x2F; &quot;Tony Stark&quot; bind函數只能作用第一次，第二次綁定只是多塞傳入參數</span><br></pre></td></tr></table></figure></div><h3 id="5-call方法："><a href="#5-call方法：" class="headerlink" title="5. call方法："></a>5. call方法：</h3><p>ES5 導入了 Function.prototype.call，可以為一個函數進行傳入參數</p><ul><li>call的第一個參數是綁定該函數的擁有物件(擁有者)。</li><li>call的第二個參數是綁定該函數的第一個參數。</li><li>call的第三個參數是綁定該函數的第二個參數。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var getFullName &#x3D; function (lastName) &#123;</span><br><span class="line">    return this.firstName + &quot; &quot; + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var IronMan &#x3D; &#123; firstName: &quot;Tony&quot; &#125;;</span><br><span class="line">var CaptainAmerica &#x3D; &#123; firstName: &quot;Steven&quot; &#125;</span><br><span class="line"></span><br><span class="line">console.log(getFullName.call(IronMan, &quot;Stark&quot;))            &#x2F;&#x2F; &quot;Tony Stark&quot;</span><br><span class="line">console.log(getFullName.call(CaptainAmerica, &quot;Rogers&quot;))    &#x2F;&#x2F; &quot;Steven Rogers&quot;</span><br></pre></td></tr></table></figure></div><h3 id="6-apply方法："><a href="#6-apply方法：" class="headerlink" title="6. apply方法："></a>6. apply方法：</h3><p>ES5 導入了 Function.prototype.apply，可以為一個函數進行傳入參數</p><ul><li>call的第一個參數是綁定該函數的擁有物件(擁有者)。</li><li>call的第二個陣列參數是綁定該函數的所有參數。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var getFullName &#x3D; function (title, lastName, msg) &#123;</span><br><span class="line">    return title + this.firstName + &quot; &quot; + lastName + &quot; &quot; + msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var IronMan &#x3D; &#123; firstName: &quot;Tony&quot; &#125;;</span><br><span class="line">var applyAry &#x3D; [&quot;[Lucas]&quot;, &quot;Stark&quot;, &quot;I Love You&quot;]</span><br><span class="line">console.log(getFullName.apply(IronMan, applyAry)) &#x2F;&#x2F; [Lucas]Tony Stark I Love You</span><br></pre></td></tr></table></figure></div><h3 id="7-CallBack函數："><a href="#7-CallBack函數：" class="headerlink" title="7.CallBack函數："></a>7.CallBack函數：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &quot;Hi I am Global&quot;;</span><br><span class="line"></span><br><span class="line">function sayHi()&#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hero &#x3D; &#123;</span><br><span class="line">  name: &quot;Hi I am a Hero&quot;,</span><br><span class="line">  act: function(cbk)&#123;</span><br><span class="line">    return cbk();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log( sayHi() );           &#x2F;&#x2F; Hi I am Global</span><br><span class="line">console.log( hero.act(sayHi) );   &#x2F;&#x2F; Hi I am Global</span><br></pre></td></tr></table></figure></div><p>分析：</p><ul><li>輸出第一次 Hi I am Global 也就是 sayHi() 很明顯沒問題</li><li>輸出第二次 Hi I am Global 也就是 hero.act(sayHi)，對於cbk作用域的上一層是Hero，但是他又執行了一次cbk，這又是典型的內部函數</li></ul><h2 id="Scope-作用階層："><a href="#Scope-作用階層：" class="headerlink" title="Scope 作用階層："></a>Scope 作用階層：</h2><p>我們來看默認操作的Scope於JavaScript的影響，一樣這邊先使用C# 進行解說：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">namespace WindowsFormsApp3</span><br><span class="line">&#123;</span><br><span class="line">    class sum_0 &#123;&#125;</span><br><span class="line">    class sum_1 &#123;&#125;</span><br><span class="line">    class sum_2 &#123;&#125;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        private string sum_0;</span><br><span class="line">        private string sum_1 &#x3D; &quot;&quot;;</span><br><span class="line">       </span><br><span class="line">        private void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            test(10);</span><br><span class="line">        &#125;</span><br><span class="line">        private void test(int sum_0)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(sum_0.GetType()); &#x2F;&#x2F; int</span><br><span class="line">            Console.WriteLine(sum_1.GetType()); &#x2F;&#x2F; string</span><br><span class="line">            Console.WriteLine(sum_2.GetType()); &#x2F;&#x2F; 會報錯，因為型別為Class無法GetType</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>根據上述Case，我們可以得出當你沒使用this來操作變數 sum，系統會依照這個優先順序來給你數值：</p><p>C#： 當前作用域(函數)的sum &gt; 上層作用域(Class Program)的sum &gt; 上上層作用域(namespace)的sum</p><p>那麼JavaScript的規則也是如此嗎？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test_1() &#123; console.log(sum) &#125;</span><br><span class="line">function test_2(sum) &#123; console.log(sum) &#125;</span><br><span class="line">function test_3() &#123; console.log(this.sum) &#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.demo_1 &#x3D; test_1;</span><br><span class="line">obj.demo_2 &#x3D; test_2;</span><br><span class="line">obj.demo_3 &#x3D; test_3;</span><br><span class="line"></span><br><span class="line">obj.sum &#x3D; 20;</span><br><span class="line">sum &#x3D; 50;</span><br><span class="line"></span><br><span class="line">obj.demo_1(); &#x2F;&#x2F; 輸出 50</span><br><span class="line">obj.demo_2(9527); &#x2F;&#x2F; 輸出 9527</span><br><span class="line">obj.demo_3(); &#x2F;&#x2F; 輸出 20</span><br></pre></td></tr></table></figure></div><p>根據上述Case，我們可以得出當你沒使用this來操作變數 sum，系統會依照這個優先順序來給你數值：</p><p>JavaScript： 當前作用域(函數)的sum &gt; window 的sum。</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/86Mvb32.png" src="/img/loading.gif" class="lazyload" title></a><br>看起來分為兩層，但事實卻是自從ES6後是分為三層，ES6加入let宣告方式，改變了層級定義，新增Block 層級。首先介紹一下層級：</p><ul><li>Global Level Scope – 國際巨星阿湯哥</li><li>Function Level Scope – 香港喜劇天王星爺</li><li>Block Level Scope – 住在隔壁號稱歌神的里長阿伯</li></ul><p>以下我們舉個例子：</p><h3 id="1-宣告在-Function-內-使用-var、let-："><a href="#1-宣告在-Function-內-使用-var、let-：" class="headerlink" title="1. 宣告在 Function 內 (使用 var、let)："></a>1. 宣告在 Function 內 (使用 var、let)：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function myFunc()&#123;</span><br><span class="line">    var n1 &#x3D; &quot;OneJar&quot;;</span><br><span class="line">    console.log(&quot;myFunc(): typeof n1&#x3D;&quot;, typeof n1, &quot; value&#x3D;&quot;, n1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunc();</span><br><span class="line">console.log(&quot;Global: typeof n1&#x3D;&quot;, typeof n1);</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myFunc(): n1&#x3D; OneJar</span><br><span class="line">Global: typeof n1&#x3D; undefined</span><br></pre></td></tr></table></figure></div><p>作用域範圍圖：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/ND1rLDN.png" src="/img/loading.gif" class="lazyload" title></a><br>紅色是 n1 宣告的地方，淺藍色部分就是 n1 的 Scope。</p><ul><li>基本 Function Scope。</li><li>只有在自己這個 function 內有效，包含 function 內的子 Block。</li><li>別的 function 不認得。</li><li>主程式區也不認得。</li></ul><h3 id="2-宣告在主程式區-使用-var-："><a href="#2-宣告在主程式區-使用-var-：" class="headerlink" title="2. 宣告在主程式區 (使用 var)："></a>2. 宣告在主程式區 (使用 var)：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myFunc()&#123;</span><br><span class="line">    console.log(&quot;myFunc(): n1&#x3D;&quot;, n1);</span><br><span class="line">    console.log(&quot;myFunc(): this.n1&#x3D;&quot;, this.n1);</span><br><span class="line">    console.log(&quot;myFunc(): window.n1&#x3D;&quot;, window.n1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var n1 &#x3D; &quot;OneJar&quot;;</span><br><span class="line">myFunc();</span><br><span class="line">console.log(&quot;Global: n1&#x3D;&quot;, n1);</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myFunc(): n1&#x3D; OneJar</span><br><span class="line">myFunc(): this.n1&#x3D; OneJar</span><br><span class="line">myFunc(): window.n1&#x3D; OneJar</span><br><span class="line">Global: n1&#x3D; OneJar</span><br></pre></td></tr></table></figure></div><p>作用域範圍圖：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/IFycsWz.png" src="/img/loading.gif" class="lazyload" title></a><br>紅色是 n1 宣告的地方，淺藍色部分就是 n1 的 Scope。</p><ul><li>基本 Global Scope。</li><li>主程式區內的所有子 Block 和函數都認得。</li></ul><h3 id="3-宣告在主程式區-使用-let-："><a href="#3-宣告在主程式區-使用-let-：" class="headerlink" title="3. 宣告在主程式區 (使用 let)："></a>3. 宣告在主程式區 (使用 let)：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myFunc()&#123;</span><br><span class="line">    console.log(&quot;myFunc(): n1&#x3D;&quot;, n1);</span><br><span class="line">    console.log(&quot;myFunc(): this.n1&#x3D;&quot;, this.n1);</span><br><span class="line">    console.log(&quot;myFunc(): window.n1&#x3D;&quot;, window.n1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let n1 &#x3D; &quot;OneJar&quot;;</span><br><span class="line">myFunc();</span><br><span class="line">console.log(&quot;Main: n1&#x3D;&quot;, n1);</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myFunc(): n1&#x3D; OneJar</span><br><span class="line">myFunc(): this.n1&#x3D; undefined</span><br><span class="line">myFunc(): window.n1&#x3D; undefined</span><br><span class="line">Main: n1&#x3D; OneJar</span><br></pre></td></tr></table></figure></div><p>作用域範圍圖：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/WrW8Ta0.png" src="/img/loading.gif" class="lazyload" title></a></p><ul><li>在執行時，主程式區因為let存在會被包裝成一個 Function 去執行 (圖中隱藏的 Main())。</li><li>所以變數 n1 不會成為 Global Scope，而是 Function Scope / Block Scope。</li></ul><h3 id="4-賦值給未宣告的變數，會自動產生的全域變數："><a href="#4-賦值給未宣告的變數，會自動產生的全域變數：" class="headerlink" title="4. 賦值給未宣告的變數，會自動產生的全域變數："></a>4. 賦值給未宣告的變數，會自動產生的全域變數：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myFunc()&#123;</span><br><span class="line">    n1 &#x3D; &quot;OneJar&quot;;  &#x2F;&#x2F; 自動變成一個 Global 變數</span><br><span class="line">    console.log(&quot;myFunc(): n1&#x3D;&quot;, n1);</span><br><span class="line">    console.log(&quot;myFunc(): this.n1&#x3D;&quot;, this.n1);</span><br><span class="line">    console.log(&quot;myFunc(): window.n1&#x3D;&quot;, window.n1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunc();</span><br><span class="line">console.log(&quot;Global: n1&#x3D;&quot;, n1);</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myFunc(): n1&#x3D; OneJar</span><br><span class="line">myFunc(): this.n1&#x3D; OneJar</span><br><span class="line">myFunc(): window.n1&#x3D; OneJar</span><br><span class="line">Global: n1&#x3D; OneJar</span><br></pre></td></tr></table></figure></div><p>作用域範圍圖：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/mcfB1Ef.png" src="/img/loading.gif" class="lazyload" title></a></p><ul><li>紫色代表 n1 = “OneJar”，也就是沒有宣告就對 n1 賦值的地方。</li><li>雖然賦值的地方是在 function 內，但因為沒有先宣告，JavaScript 的行為會自動將 n1 產生為 Global 變數，所以變成 Global Scope。</li></ul><h3 id="5-Global-和-Function-內同時存在同名變數："><a href="#5-Global-和-Function-內同時存在同名變數：" class="headerlink" title="5. Global 和 Function 內同時存在同名變數："></a>5. Global 和 Function 內同時存在同名變數：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function myFunc()&#123;</span><br><span class="line">    var n1 &#x3D; &quot;Stephen Chow&quot;;</span><br><span class="line">    console.log(&quot;myFunc(): n1&#x3D;&quot;, n1);</span><br><span class="line">    console.log(&quot;myFunc(): this.n1&#x3D;&quot;, this.n1);</span><br><span class="line">    console.log(&quot;myFunc(): window.n1&#x3D;&quot;, window.n1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var n1 &#x3D; &quot;Tom Cruise&quot;;</span><br><span class="line">myFunc();</span><br><span class="line">console.log(&quot;Global: n1&#x3D;&quot;, n1);</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myFunc(): n1&#x3D; Stephen Chow</span><br><span class="line">myFunc(): this.n1&#x3D; Tom Cruise</span><br><span class="line">myFunc(): window.n1&#x3D; Tom Cruise</span><br><span class="line">Global: n1&#x3D; Tom Cruise</span><br></pre></td></tr></table></figure></div><p>作用域範圍圖：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/xO04ZSB.png" src="/img/loading.gif" class="lazyload" title></a></p><ul><li>紅色是 var n1 = “Tom Cruise”，宣告在主程式區，屬於 Global Scope。</li><li>綠色是 var n1 = “Stephen Chow”，宣告在主程式區，屬於 Function Scope。</li><li>淺藍色區域，會生效的是紅色的 n1</li><li>黃色區域，會生效的是綠色的 n1</li></ul><h3 id="6-Block-內使用-var-宣告："><a href="#6-Block-內使用-var-宣告：" class="headerlink" title="6. Block 內使用 var 宣告："></a>6. Block 內使用 var 宣告：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(true)&#123;</span><br><span class="line">   var x &#x3D; 2;</span><br><span class="line">   &#123;</span><br><span class="line">        console.log(x); &#x2F;&#x2F; 2</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(x); &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure></div><p>作用域範圍圖：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/OtwGCUq.png" src="/img/loading.gif" class="lazyload" title></a></p><ul><li>傳統 var 不支援 Block Scope。</li><li>若是宣告在主程式區的 Block，會是 Global Scope (如上圖所示)。</li><li>若是宣告在函數內的 Block 內 (例如 Block C 內)，會是 Function Scope。</li></ul><h3 id="7-Block-內使用-let-宣告："><a href="#7-Block-內使用-let-宣告：" class="headerlink" title="7. Block 內使用 let 宣告："></a>7. Block 內使用 let 宣告：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(true)&#123;</span><br><span class="line">   let x &#x3D; 2;</span><br><span class="line">   &#123;</span><br><span class="line">        console.log(x); &#x2F;&#x2F; 2</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(x); &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(x); &#x2F;&#x2F; ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></div><p>作用域範圍圖：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/f6mZEed.png" src="/img/loading.gif" class="lazyload" title></a></p><ul><li>使用 let 或 const 宣告變數，支援 Block Scope 效果。</li><li>變數 x 只會在被宣告的那個 Block 和其子 Block 被認得。</li></ul><h3 id="嚴格模式："><a href="#嚴格模式：" class="headerlink" title="嚴格模式："></a>嚴格模式：</h3><p>由上述可以知道JavaScript的語法很寬鬆，容易產生Bug，所以W3C定義了嚴格模式<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/Ms7yxdK.png" src="/img/loading.gif" class="lazyload" title></a><br>只要你在主程式或函數的開頭加入  “use strict” 就會開啟嚴格模式。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">x &#x3D; 123;            &#x2F;&#x2F; ReferenceError: x is not defined</span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function f1()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( f1() ); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure></div><p>如果是TypeScript可以在tsconfig.json開啟該模式。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/15AZcFh.png" src="/img/loading.gif" class="lazyload" title></a></p><h2 id="變量、函數提升："><a href="#變量、函數提升：" class="headerlink" title="變量、函數提升："></a>變量、函數提升：</h2><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/E7hxpyY.png" src="/img/loading.gif" class="lazyload" title></a><br>根據W3C的規範，他們說JavaScript需要變量提升和函數提升。我們來看例子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(x);</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></div><p>很明顯你使用了沒宣告的變數，當然報錯，這是基本程式語言概念。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(x);</span><br><span class="line">var x &#x3D; &quot;OneJar&quot;;</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br></pre></td></tr></table></figure></div><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/awSRM6k.png" src="/img/loading.gif" class="lazyload" title></a><br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/Gk58O6O.png" src="/img/loading.gif" class="lazyload" title></a></p><p>其實背後的機制是變量提升，當上面寫法被變量提升後，它等同於下面這種寫法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line">console.log(x);</span><br><span class="line">x &#x3D; &quot;OneJar&quot;;</span><br></pre></td></tr></table></figure></div><p>對於函數也是有提升效果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line"></span><br><span class="line">function sayHi()&#123;</span><br><span class="line">console.log(&#39;Hi&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi</span><br></pre></td></tr></table></figure></div><p>但是 當你使用let 或是 const(ES6跟let一起加入的宣告方式)，就不具備提升效果，例子如下：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/mYoYcYX.png" src="/img/loading.gif" class="lazyload" title></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(x);</span><br><span class="line">let x &#x3D; &quot;OneJar&quot;;</span><br></pre></td></tr></table></figure></div><p>執行結果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></div><h2 id="汙染變數："><a href="#汙染變數：" class="headerlink" title="汙染變數："></a>汙染變數：</h2><p>假設今天obj是個模組，對於使用者來說只要使用setMsg 和 showMsg就足夠，但是很明顯 msg 和 getMsg 暴露了，這樣會導致不熟悉模組的人亂操作，就會汙染變數或是函數，讓模組安全性降低。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.msg &#x3D; &quot;null&quot;;</span><br><span class="line">obj.setMsg &#x3D; function (newMsg) &#123;this.msg &#x3D; newMsg&#125;;</span><br><span class="line">obj.getMsg &#x3D; function () &#123;return this.msg&#125;;</span><br><span class="line">obj.showMsg &#x3D; function () &#123;console.log(this.getMsg())&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------使用者場景----------</span><br><span class="line">obj.setMsg(&quot;Lucas&quot;);</span><br><span class="line">obj.showMsg();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------汙染行為----------</span><br><span class="line">obj.getMsg &#x3D; function () &#123; return &quot;Fuck&quot;&#125;;</span><br><span class="line">obj.msg &#x3D; &quot;You&quot;;</span><br></pre></td></tr></table></figure></div><p>或許會有人說 TypeScript的 private 和 Class 機制可以防止該問題，的確，但還是無法阻擋有心人：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MsgManger</span><br><span class="line">&#123;</span><br><span class="line">    private msg: string &#x3D; &quot;null&quot;;</span><br><span class="line">    private getMsg(): string &#123; return this.msg &#125;;</span><br><span class="line"></span><br><span class="line">    public setMsg(newMsg): void &#123; this.msg &#x3D; newMsg &#125;;</span><br><span class="line">    public showMsg(): void &#123; console.log(this.getMsg()) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj : MsgManger &#x3D; new MsgManger();</span><br><span class="line">obj.setMsg(&quot;Lucas&quot;);</span><br><span class="line">obj[&quot;msg&quot;] &#x3D; &quot;Fuck&quot;; &#x2F;&#x2F; 強制修改方法</span><br><span class="line">obj.showMsg(); &#x2F;&#x2F; 輸出為 Fuck</span><br></pre></td></tr></table></figure></div><h2 id="閉包："><a href="#閉包：" class="headerlink" title="閉包："></a>閉包：</h2><p>針對這問題其中一個解決方法就是閉包</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Closure() &#123;</span><br><span class="line">    var msg &#x3D; &quot;Null&quot;;</span><br><span class="line">    function getMsg() &#123; return msg &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        setMsg: function (newMsg) &#123; msg &#x3D; newMsg &#125;,</span><br><span class="line">        showMsg: function () &#123; console.log(getMsg()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; Closure()</span><br><span class="line"></span><br><span class="line">obj.setMsg(&quot;Lucas&quot;);</span><br><span class="line">obj.showMsg();</span><br><span class="line"></span><br><span class="line">console.log(obj.msg + &quot; test&quot;)</span><br></pre></td></tr></table></figure></div><p>執行結果：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/XQdQcSC.png" src="/img/loading.gif" class="lazyload" title></a></p><p>立即執行返回一個對象，主要利用 局部 Scope 和return來實現。</p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> runtime </tag>
            
            <tag> Scope </tag>
            
            <tag> var </tag>
            
            <tag> let </tag>
            
            <tag> const </tag>
            
            <tag> this </tag>
            
            <tag> bind </tag>
            
            <tag> call </tag>
            
            <tag> apply </tag>
            
            <tag> HTML </tag>
            
            <tag> CallBack </tag>
            
            <tag> 嚴格模式 </tag>
            
            <tag> Hoisting </tag>
            
            <tag> 汙染變數 </tag>
            
            <tag> 閉包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.11 - 模組</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.11%20-%20%E6%A8%A1%E7%B5%84/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.11%20-%20%E6%A8%A1%E7%B5%84/</url>
      
        <content type="html"><![CDATA[<h1 id="模組："><a href="#模組：" class="headerlink" title="模組："></a>模組：</h1><p>在污染變數那一章中，我們提到使用別人的模組亂操作的下場，所以應該使用閉包來避免讓別人亂操作，但是模組這東西在JavaScript又是個災難。<br>因為在ES6之前還沒有模組化標準給大家用，在ES6之前都是如果你include兩份JS模組：</p><p>第一份為SayHello模組宣告了 temp 在window這個作用域上<br>第二份為SayHell 模組宣告了 temp 在window這個作用域上</p><p>根據上述作用域問題我們知道需叫 temp.Say();，原本預計會是Hello，但是你不知道第二份模組物件名稱衝突了，於是變成Hell。<br>所以呢在ES6之前熱心的JavaScript社群們提出一些模組化加載方案，主要可以分為兩派：CommonJS  和 AMD 流派，而ES6之後推出官方標準，所以我們當前JavaScript在加載模組時候有三種標準(1個官方、兩個野雞自幹派)，但是ES6是後來官方才推出的標準所以實現了完全取代CommonJS 和 AMD流派，並且ES6官方設計能夠達到靜態優化。</p><h2 id="模組化的歷史："><a href="#模組化的歷史：" class="headerlink" title="模組化的歷史："></a>模組化的歷史：</h2><p>大概在2009年當時有個社群叫做CommonJS，該社群有很多大佬，這群大佬推出了 ServerJS 的規範，用於處理模塊加載，這個規範在NodeJS上實踐了並且效果不錯，於是這群大佬又推出了新版本，並且要讓這規範能夠支援瀏覽器，所以把 ServerJS 改名為 CommonJS ，這次新版本不是那麼順利，內部爭議不斷於是分歧就產生了。</p><p>分歧產生了 Modules/Async 流派，這個流派提議，當前瀏覽器特徵不應該直接使用這個規範，並提出自己的規範，但是該規範被受社群內部爭議，於是這個流派被CommonJS社群獨立出去了，該流派的人把規範取名為同名AMD並且自創了一個社群同名AMD社群，就是第二個流派的規範，他們的runtime 是 RequireJS，當然這其中還有一些爭議，像是CommonJS說你不能在說明文檔打著CommonJS的名號或標誌。</p><p>分歧產生了 Modules/2.0 流派，這個流派跟AMD那夥人差不多但是應該盡可能與舊版規範保持一致。所以該派也獨立了，成立CMD規範，但很可惜當時 RequireJS 非常火，被打敗了。其中作者把GitHub和官網清空，只留下一句話「我會回來的，帶著更好的東西」，就此消失。這句話給一個工程師有很大的影響，於是那個人將CMD實做在seaJS。</p><p>上述歷史中總共有三個野雞流派，但是只有一人生存至今，CommonJS負責Sever的NodeJS部分，而後續官方推出的ES6模塊標準則負責瀏覽器端。故以下我們用這兩者進行比對和範例。</p><h2 id="靜態優化："><a href="#靜態優化：" class="headerlink" title="靜態優化："></a>靜態優化：</h2><p>首先CommonJS 和 AMD 在加載模組時候都只能在運行時才能確定這些東西，舉個範例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let &#123; stat, exists, readFile &#125; &#x3D; require(&#39;.&#x2F;fs&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同於以下操作</span><br><span class="line">let _fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">let stat &#x3D; _fs.stat;</span><br><span class="line">let exists &#x3D; _fs.exists;</span><br><span class="line">let readfile &#x3D; _fs.readfile;</span><br></pre></td></tr></table></figure></div><p>這種加載方式會有個問題，只有運行到時候才能得到這個物件，導致沒辦法在編譯階段進行優化，簡稱無法進行靜態優化。<br>那麼ES6官方版的模組化加載方案是如何做到：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">這是ES6官方版本的模塊加載方案：</span><br><span class="line">import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;</span><br></pre></td></tr></table></figure></div><p>上面的程式碼是直接去fs模組加載這三個函數，而其他沒指定的函數就不會進行加載，這種方式可以實現在編譯時後就進行編譯，就導致模組加載的效率會比CommonJS快，因為不是執行到那行時候才加載。</p><h2 id="CommonJS："><a href="#CommonJS：" class="headerlink" title="CommonJS："></a>CommonJS：</h2><p>該規範主要運用於服務器端，也就是NodeJS，他新增了一個函數叫做：「require」 以及 「exports」這個物件，對應了導入和導出功能。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Math.js</span><br><span class="line">exports.add &#x3D; function(a,b) &#123;return a + b&#125;;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Main.js</span><br><span class="line">var MathObj &#x3D; require(&#39;.&#x2F;Math&#39;);</span><br><span class="line">console.log(MathObj.add(2,3));</span><br></pre></td></tr></table></figure></div><p>而以上就是CommonJS這個規範所制定的模組加載部分，而規範就是規範，還是要有人實做，於是NodeJS跳出來說我將實現這個規範，於是我們可以在NodeJS這個runtime實現該規範的加載方案。<br>而在模組部分，CommonJS 輸出的是一個值的拷貝，並且是運行時加載。</p><h3 id="快取緩存值的問題："><a href="#快取緩存值的問題：" class="headerlink" title="快取緩存值的問題："></a>快取緩存值的問題：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; lib.js</span><br><span class="line">var counter &#x3D; 3;</span><br><span class="line">function incCounter() &#123; counter++; &#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var mod &#x3D; require(&#39;.&#x2F;lib&#39;);</span><br><span class="line"></span><br><span class="line">console.log(mod.counter);  &#x2F;&#x2F; 3</span><br><span class="line">mod.incCounter();</span><br><span class="line">console.log(mod.counter); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure></div><p>理論上應該要是被累加輸出成4，但是因為他是拷貝，mod.counter在一開始require時後就被快取緩存下來了，所以不受到內部影響，因為這邊是獲取緩存的結果，這是因為這是個值而不是函數，所以被快取下來。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; lib.js</span><br><span class="line">var counter &#x3D; 3;</span><br><span class="line">function incCounter() &#123; counter++; &#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  get counter() &#123; return counter &#125;,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>我們將 mod.counter 對外導出，並且是個存取子是個函數，無法被快取，就可以獲得正確被累加的結果。</p><h3 id="CommonJS如何實現在瀏覽器端？"><a href="#CommonJS如何實現在瀏覽器端？" class="headerlink" title="CommonJS如何實現在瀏覽器端？"></a>CommonJS如何實現在瀏覽器端？</h3><p>由上述歷史和例子我們可以知道，今天如果你專案採用CommonJS來加載模組，那麼你的runtime不就只能在NodeJS嗎？ 瀏覽器只認得ES標準，誰會處理CommonJS這個野雞派的規範，於是有人利用NodeJS開發一個工具叫做 Babel 同名於 聖經中的巴別塔，其用法後續會介紹。</p><p>利用Babel 可以把CommonJS的模塊加載改成瀏覽器認得的 ES6模塊加載規則，而Babel 功能不只如此，不然怎麼敢跟巴別塔同名的膽子，他還可以把高版本的ES轉成低版本的ES，也就是我不用管瀏覽器支援哪個版本，我一慮用ES10爽爽寫，Babel 會幫我翻譯成瀏覽器能認得的ES版本。</p><h2 id="ES6模組標準："><a href="#ES6模組標準：" class="headerlink" title="ES6模組標準："></a>ES6模組標準：</h2><p>該規範主要運用於瀏覽器端，他新增了兩個函數叫做：「import」 以及 「export」，對應了導入和導出功能。</p><h3 id="export："><a href="#export：" class="headerlink" title="export："></a>export：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; profile.js</span><br><span class="line">export var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">export var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">export var year &#x3D; 1958;</span><br><span class="line">export function sayHello() &#123; console.log(&quot;hello&quot;)&#125;</span><br></pre></td></tr></table></figure></div><p>以上寫法等價於下方寫法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; profile.js</span><br><span class="line">var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">var year &#x3D; 1958;</span><br><span class="line">function sayHello() &#123; console.log(&quot;hello&quot;) &#125;</span><br><span class="line"></span><br><span class="line">export &#123; firstName, lastName, year, sayHello &#125;;</span><br></pre></td></tr></table></figure></div><p>以上寫法等價於下方寫法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; profile.js</span><br><span class="line">var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">var year &#x3D; 1958;</span><br><span class="line">function sayHello() &#123; console.log(&quot;hello&quot;) &#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    firstName as FName,</span><br><span class="line">    lastName as LName,</span><br><span class="line">    year as Year,</span><br><span class="line">    sayHello as LogHello</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>第四種 export default 寫法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; profile.js</span><br><span class="line">var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">var year &#x3D; 1958;</span><br><span class="line">function sayHello() &#123; console.log(&quot;hello&quot;) &#125;</span><br><span class="line">export default &#123;</span><br><span class="line">    firstName,</span><br><span class="line">    lastName,</span><br><span class="line">    year,</span><br><span class="line">    sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以上就是export 的寫法，而ES6 export 不像是 CommonJS 的 exports 會有快取緩存問題</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export var foo &#x3D; &#39;bar&#39;;</span><br><span class="line">setTimeout(() &#x3D;&gt; foo &#x3D; &#39;baz&#39;, 500);  &#x2F;&#x2F; 該行功能是一開始是bar 經過0.5 秒後會真的變成baz</span><br></pre></td></tr></table></figure></div><h3 id="import："><a href="#import：" class="headerlink" title="import："></a>import：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js 對應於第一、二、三種export方法</span><br><span class="line">import &#123; firstName, lastName, year , sayHello&#125; from &#39;.&#x2F;profile.js&#39;;</span><br><span class="line">sayHello();</span><br></pre></td></tr></table></figure></div><p>其中import的變數名稱必須跟export一模一樣，如果只想導入其中一個並且想改名可以使用以下方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js 對應於第一、二、三種export方法</span><br><span class="line">import &#123; sayHello as sayMyName&#125; from &#39;.&#x2F;profile.js&#39;;</span><br><span class="line">sayMyName();</span><br></pre></td></tr></table></figure></div><p>而如果想import所有項目的話可以使用以下方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import * as Obj_profile from &#39;.&#x2F;profile&#39;;</span><br><span class="line">Obj_profile.sayHello();</span><br></pre></td></tr></table></figure></div><p>而第四種export 方式 可以使用以下import 方式使用：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import Obj_profile from &quot;.&#x2F;profile&quot;; &#x2F;&#x2F; 引入了profile.js</span><br><span class="line">Obj_profile.sayHello();</span><br></pre></td></tr></table></figure></div><h3 id="ES6模組標準如何實現在NodeJS？"><a href="#ES6模組標準如何實現在NodeJS？" class="headerlink" title="ES6模組標準如何實現在NodeJS？"></a>ES6模組標準如何實現在NodeJS？</h3><p>NodeJS改版後也開始支援ES6模塊語法，但是原本NodeJS就有自己的模塊標準 CommonJS ，現在還要相容另一種 ES6模塊標準，所以NodeJS要求</p><p>在package.json 未開啟type或 type為commonjs的情況，採用ES6標準模組的檔案必須命名為 .mjs ，並且會自動開啟嚴格模式。<br>在package.json 未開啟type或 type為commonjs的情況，採用CommonJS的檔案必須命名為 .js。</p><p>在package.json 開啟type為module的情況，採用ES6標準模組的檔案必須命名為 .js。<br>在package.json 開啟type為module的情況，採用CommonJS的檔案必須命名為 .cjs。</p><p>這樣NodeJS就會採取不同的模組標準去解釋該文件，而 commonjs 和 ES6混用 為不推薦做法，因為兩者在靜態優化的差異，可能會有BUG</p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> runtime </tag>
            
            <tag> NodeJS </tag>
            
            <tag> ES6 </tag>
            
            <tag> ES5 </tag>
            
            <tag> ServerJS </tag>
            
            <tag> CommonJS </tag>
            
            <tag> AMD </tag>
            
            <tag> RequireJS </tag>
            
            <tag> CMD </tag>
            
            <tag> seaJS </tag>
            
            <tag> 靜態優化 </tag>
            
            <tag> require </tag>
            
            <tag> exports </tag>
            
            <tag> import </tag>
            
            <tag> export </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.06 - WebAssembly</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.06%20-%20WebAssembly/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.06%20-%20WebAssembly/</url>
      
        <content type="html"><![CDATA[<h1 id="WebAssembly："><a href="#WebAssembly：" class="headerlink" title="WebAssembly："></a>WebAssembly：</h1><p>還記得JIT是如何解決效能低下的方式嗎，偵測到這段程式碼被頻繁呼叫，我就把解釋結果(機器語言)儲存起來，當下次又呼叫就不進行解釋直接將結果丟出來，走火入魔的工程師們認為這也是效能問題，為什麼要執行很多次才能被優化呢，而且優化過程還會浪費效能，所以就有人提出如果一開始網頁識別的文件就是機器語言呢。</p><p>還記得TypeScript是如何解決弱型別的問題嗎，使用強型別方式，最後把程式碼丟給tsc進行編譯轉換成JavaScript。但是TypeScript身為嚴格超集必定支援JavaScript，於是又犯了弱型別缺陷問題，走火入魔的工程師們認為這也是個問題，於是提出使用強型別語言進行開發，因為理論上所有強型別語言都可以被轉換成機器語言。很明顯TypeScript不是推薦的強型別。</p><p>因為JavaScript的垃圾回收機制(GC)，是無法控制的，時間到他就會自己進行清除，這也會是個問題，因為GC機制當GC清除時候，會把所有程式暫停住，之後開始清除物件挪出更多的記憶體，工程師們認為GC不可控是很糟糕的表現，要是我在畫面最華麗時候突然來個GC那不就卡卡的嗎。</p><p>綜合上述三者問題，工程們規劃出WebAssbly應該是能夠自主控制GC，並且是由真正的強型別的程式語言所開發，並且能夠在當前瀏覽器不支援WebAssbly時候轉換成JavaScript，所以當前四大龍頭組織推出C++為WebAssbly的核心，其大概長這樣：</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/EnsjTwX.png" src="/img/loading.gif" class="lazyload" title></a></p><p>當然WebAssbly還沒有成熟，但是WebAssembly 於 2019 年 12 月 5 日成為全球資訊網協會（W3C）的推薦，與 HTML，CSS 和 JavaScript 一起，成為 Web 的第四種語言。(Form Wiki)。如果成熟的話前端又會再重新翻牌，而比這翻牌比TypeScript帶來的影響更多。</p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebAssembly </tag>
            
            <tag> C++ </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.07 - jQuery &amp; AJAX歷史</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.07%20-%20jQuery%20&amp;%20AJAX%E6%AD%B7%E5%8F%B2/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.07%20-%20jQuery%20&amp;%20AJAX%E6%AD%B7%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery:"></a>jQuery:</h1><p>而在前端開發過程中，免不了使用一個函示庫，可以說你如果不知道jQuery就無法寫前端，而jQuery你可以把它當作API或是第三方庫來使用，主要業務內容是 簡化HTML與JavaScript之間的操作，可至官方網站進行下載該庫：<a href="https://jquery.com/" target="_blank" rel="noopener">https://jquery.com/</a><br>根據維基百科jQuery採用工廠模式設計，所以凡是看到：$. 都是呼叫jQuery的函式，在以前前端世界如果你沒用過jQuery那就不能叫做前端，因為這個庫太好用了，但是最近jQuery也不見得是必要的函示庫，但是其設計概念很值得參考。</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/SadDbPL.png" src="/img/loading.gif" class="lazyload" title></a></p><p>以上是jQuery提供的函示庫，此處就不再進行介紹，詳情請參考：<a href="https://www.w3school.com.cn/jquery/event_click.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/jquery/event_click.asp</a><br>後續介紹的AJAX將會使用jQuery來當作實作範例。</p><h1 id="AJAX："><a href="#AJAX：" class="headerlink" title="AJAX："></a>AJAX：</h1><p>AJAX是當前前端會經常使用的功能，也是網頁的特色之一，下載功能，要解釋AJAX是什麼我們先釐清在AJAX出現之前，前端到底是長怎樣<br>AJAX出現前：假設今天你在看股票網站，而股票大盤每一秒都在變化，如果你要看最新的大盤訊息，你就必須重新整理頁面才能看到最新的資料。<br>AJAX出現後：假設今天你在看股票網站，而股票大盤每一秒都在變化，而大盤畫面就會自動變化，你也不用重新整理頁面來刷新。</p><p>所以從上述可以得知AJAX是可以解決即時更動介面及內容，不需要重新讀取整個網頁，讓程式更快回應使用者的操作。其全名為 異步 JavaScript 及 XML（Asynchronous JavaScript and XML，AJAX）。最初微軟意識到這問題，於是開發了ActiveXObject給開發者使用，用了才知道原來這麼好用，很多開發者以此API開發了諸多著名軟體 Gmail就是其中一個AJAX應用代表，於是其他瀏覽器廠商也跟風發開發起類似接口，但是為了相容性，總不可能這功能在IE叫做ActiveXObject，而在火狐又叫做另一個名稱，這樣工程師還不發飆給你看，於是W3C組織開始統一為XMLHttpRequest，但是早期的瀏覽器像是IE 還是叫做 ActiveXObject，於是就有了以下寫法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (window.XMLHttpRequest) &#123; &#x2F;&#x2F; 如果當前支援W3C制定的標準名稱XMLHttpRequest的話 (其瀏覽器：Mozilla, Safari, IE7+ ...)</span><br><span class="line">    httpRequest &#x3D; new XMLHttpRequest();</span><br><span class="line">&#125; else if (window.ActiveXObject) &#123; &#x2F;&#x2F; 如果當前不支援XMLHttpRequest，那判斷是否為支援ActiveXObject (其瀏覽器：IE 6 and older)</span><br><span class="line">    httpRequest &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> W3C </tag>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
            <tag> AJAX </tag>
            
            <tag> XMLHttpRequest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.08 - AJAX &amp; 跨域</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.08%20-%20AJAX%20&amp;%20%E8%B7%A8%E5%9F%9F/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.08%20-%20AJAX%20&amp;%20%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="XMLHttpRequest："><a href="#XMLHttpRequest：" class="headerlink" title="XMLHttpRequest："></a>XMLHttpRequest：</h1><p>上回解釋了AJAX的簡介，那這次我們來實作，根據MDN上的說明，可以使用以下程式碼來操作XMLHttpRequest。</p><h6 id="MDN-是由瀏覽器四巨頭的Mozilla創建的JavaScript-API文檔網站"><a href="#MDN-是由瀏覽器四巨頭的Mozilla創建的JavaScript-API文檔網站" class="headerlink" title="MDN 是由瀏覽器四巨頭的Mozilla創建的JavaScript API文檔網站"></a>MDN 是由瀏覽器四巨頭的Mozilla創建的JavaScript API文檔網站</h6><ol><li>網站上說明，需要使用該方法進行初始化<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/nw2N3N3.png" src="/img/loading.gif" class="lazyload" title></a></li><li>可以使用open這個函數來初始化請求(就是你要互動的行為是什麼)<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/O5S5x1d.png" src="/img/loading.gif" class="lazyload" title></a></li><li>open函數，有2個必填參數，1個可有可無的參數<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/NX7WFly.png" src="/img/loading.gif" class="lazyload" title></a></li><li>method傳入String變數對應的功能：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/L62odWM.png" src="/img/loading.gif" class="lazyload" title></a></li><li>傳送我的互動要求<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/Y3ABtDP.png" src="/img/loading.gif" class="lazyload" title></a></li><li>查詢我的結果<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/UrHBybe.png" src="/img/loading.gif" class="lazyload" title></a></li></ol><p>由上圖可以知道用程式碼來寫，初始化應該是這樣：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest(); &#x2F;&#x2F; 初始化物件</span><br><span class="line">xhr.open(&quot;GET&quot; , &quot;resource&#x2F;config.json&quot; , false) &#x2F;&#x2F; 初始化指令，告知我需要與 resource&#x2F;config.json 這個路徑進行獲取的互動，並且採用異步方式。</span><br><span class="line">xhr.send(); &#x2F;&#x2F; 傳送指令</span><br><span class="line">console.log(xhr.response) &#x2F;&#x2F; 把結果印出來</span><br></pre></td></tr></table></figure></div><p>可以從圖中看出，已經正確發出請求了<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/Xq13s0V.png" src="/img/loading.gif" class="lazyload" title></a></p><ol><li>xhr 是說明使用 XMLHttpRequest 的請求方式 </li><li>status 是狀態碼</li></ol><ul><li>200 - 請求成功</li><li>301 - 資源（網頁等）被永久轉移到其它URL</li><li>404 - 請求的資源（網頁等）不存在</li><li>500 - 內部伺服器錯誤</li></ul><h1 id="緩存問題："><a href="#緩存問題：" class="headerlink" title="緩存問題："></a>緩存問題：</h1><p>今天如果我跟Server請求一張圖片叫做A，Server丟給你後瀏覽器會自動幫你把圖快取下來，然後隔了10分鐘我又請求一次了，但是這時後瀏覽器認為我又要A這張圖，就會把我的請求擋住，並把快取裡面的A圖給你，這樣能夠有效節省請求消耗，這是一種優化效能手段。<br>但是也會產生，如果我要的A圖在這10分鐘被換掉，但是網頁機制還是認為我又要同張圖，把我請求擋掉，於是我就拿不到新的A圖，這問題就是緩存、快取問題，而這問題會導致今天要臨時更換驗證圖、監控系統的監控圖等等，無法順利替換。<br>為了解決這問題我們採用新增時間標籤，像是圖片叫做A，我們改為 A?v=20190203代表2月3日拿到的資料，而2月4日拿到的新圖片則取名為A?v=20190204，這樣系統就會認定這兩個東西是完全不同的東西，就不會有緩存的問題了。</p><p>或是加入CRC檢查碼、哈希值等等特殊數學運算碼，CRC檢查可以碼請參考「OSI七層」。</p><h1 id="跨域問題："><a href="#跨域問題：" class="headerlink" title="跨域問題："></a>跨域問題：</h1><p>何謂跨域，自從人們發明AJAX後發現一些安全性的問題，於是對AJAX設定了一個同源策略(<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5)，跨域就是當處於非同源時發起的請求，這種行為叫做跨域，首先我們先了解什麼是同源：" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5)，跨域就是當處於非同源時發起的請求，這種行為叫做跨域，首先我們先了解什麼是同源：</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假設目前使用者在：http:&#x2F;&#x2F;store.company.com：</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;store.company.com&#x2F;dir2&#x2F;other.html同源 </span><br><span class="line">http:&#x2F;&#x2F;store.company.com&#x2F;dir&#x2F;inner&#x2F;another.html同源 </span><br><span class="line">https:&#x2F;&#x2F;store.company.com&#x2F;secure.html不同源協定不同</span><br><span class="line">http:&#x2F;&#x2F;store.company.com:81&#x2F;dir&#x2F;etc.html不同源埠號不同</span><br><span class="line">http:&#x2F;&#x2F;news.company.com&#x2F;dir&#x2F;other.html不同源主機位置不同</span><br></pre></td></tr></table></figure></div><p>以上Case定義了什麼情況算是同源，什麼情況算是非同源，而如果你身在<a href="https://example.com" target="_blank" rel="noopener">https://example.com</a> 網址發起<a href="https://google.com" target="_blank" rel="noopener">https://google.com</a> 的請求資料，很明顯為非同源，於是就會產生跨域問題，瀏覽器為了安全性將這個動作視為失敗處理，也就是請求Error。</p><p>為什麼跨域這會是個問題？<br>設想這樣一種情況：使用者開啟了A網站，A網站是一家網路銀行，使用者登入以後，又去瀏覽駭客網站(A片網站之類的)。而駭客網站裡的程式碼，發出請求讀取A網站的 Cookie，會發生什麼？很顯然，如果 Cookie 包含隱私（比如存款總額、帳號資訊等等），這些資訊就會洩漏。<br>於是有了同源政策以此來保護使用者，但仍有一些駭客發現同源政策的漏洞進行攻擊：CSRF 、XSS、JSON Hijacking等等攻擊。</p><p>值得注意的是，跨域請求雖然會被瀏覽器擋下來，但攔截的是回應（Response），不是請求（Request），請求指定的內容仍然會完成，開發者要特別注意這點！</p><p>但如果要部份解決跨域問題還是可以的，以下提出三種方案：CORS、代理伺服器、JSONP</p><h2 id="CORS："><a href="#CORS：" class="headerlink" title="CORS："></a>CORS：</h2><p>最標準、正確的解決方法是透過 W3C 規範 的「跨來源資源共用（Cross-Origin Resource Sharing，CORS）」，透過 伺服器在 HTTP Header 的設定，讓瀏覽器能取得不同來源的資源。<br>CORS 規範中，清楚定義了跨域存取控制的運作方式。</p><p>全球資訊網協會(W3C)，提出了CORS該規範紀載著只要發送請求時的 Origin 和回應的 header 中 Access-Control-Allow-Origin 的值相同，或是Access-Control-Allow-Origin: * （代表允許任何網域存取資源），此時就會放寬 CORS 的限制，允許存取跨域資源。於是製作瀏覽器的公司都會遵守這些規則。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Acess-Control-Allow-Origin: * &#x2F;&#x2F; 任何人發起請求都可以無視同源規則。</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;store.company.com &#x2F;&#x2F; 只有身處這個網址的人可以無視同源規則。</span><br></pre></td></tr></table></figure></div><p>當然這是要請後端配合的，讓可以跨域的資源設定Header加入CORS，此處就不進行講述。</p><h2 id="代理伺服器："><a href="#代理伺服器：" class="headerlink" title="代理伺服器："></a>代理伺服器：</h2><p>回憶一下，跨域請求為什麼會失敗嗎，因為W3C制定的規範，於是瀏覽器開發商就會遵守這規則，也就是「只有」瀏覽器會限制跨域，那麼我不用瀏覽器發請求，而是用代理伺服器呢，這樣就必定不會受到跨域影響。</p><p>代理伺服器有很多方案，自己架或是使用別人架好的伺服器並且提供API給你，此處我們使用別人架好的當作示範：</p><p>首先我要拿的資料是源自於：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>而我選擇別人架好的代理伺服器是：<a href="https://cors-anywhere.herokuapp.com/" target="_blank" rel="noopener">CORS-ANYWHER</a></p><p>根據代理伺服器官網的使用說明，只要將<a href="https://cors-anywhere.herokuapp.com/" target="_blank" rel="noopener">https://cors-anywhere.herokuapp.com/</a> 後面加入你要解析的URL就可以獲取非跨域的資料，像是<a href="https://cors-anywhere.herokuapp.com/https://github.com/。" target="_blank" rel="noopener">https://cors-anywhere.herokuapp.com/https://github.com/。</a></p><p>而CORS-ANYWHER 設定所有人都可以跨域獲取這個網頁的資源，所以我們可以在任何地點發起請求這個代理伺服器API服務。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/JHELeST.png" src="/img/loading.gif" class="lazyload" title></a></p><p>之後我們再次使用xhr發起請求：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest(); &#x2F;&#x2F; 初始化物件</span><br><span class="line">xhr.open(&quot;GET&quot; , &quot;https:&#x2F;&#x2F;cors-anywhere.herokuapp.com&#x2F;https:&#x2F;&#x2F;github.com&#x2F;&quot; , false)</span><br><span class="line">xhr.send(); &#x2F;&#x2F; 傳送指令</span><br><span class="line">console.log(xhr.response) &#x2F;&#x2F; 把結果印出來</span><br></pre></td></tr></table></figure></div><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/KuEYTq0.png" src="/img/loading.gif" class="lazyload" title></a></p><p>這樣雖然能解決跨域問題，但以此為延伸 </p><ol><li>效率低下 CORS-ANYWHER這個網站很夯，用的人很多而且是免費，執行速度超慢 </li><li>因為是由代理伺服器發起，所以你自身其他網站(銀行網站)的Cookie並不會被獲取</li><li>如果自己架代理伺服器，也會因為資料要轉第三手才能拿到，效率也是低，如果上線後用的人就變多的也就慢了，但還是比CORS-ANYWHER快</li></ol><h2 id="JSONP："><a href="#JSONP：" class="headerlink" title="JSONP："></a>JSONP：</h2><p>在同源規範中(<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5)，HTML沒有跨域限制的標籤如" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5)，HTML沒有跨域限制的標籤如</a> img、script 等等，也就是說使用這些標籤就可以進行跨域操作<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/lSoDpx9.png" src="/img/loading.gif" class="lazyload" title></a><br>其實這就是透過JSONP(JSON with Padding)傳輸的，將JSON資料填入Padding(Padding就是要呼叫的函式)，說白了就是使用標籤漏洞去獲取指定的東西，之後自動去呼叫這個東西，以下為透過jQuery.ajax跨站請求為範例(要測試請自己去有下載jQuery的網站F12實作，Wiki就是不錯的選擇)：</p><p>被請求的東西： LucasTest.js</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LucasCallBack(&quot;Here&#39;s ~~~~~~ Lucas&quot;);</span><br><span class="line">temp&#x3D;&quot;Here&#39;s ~~~~~~ Johnny&quot;</span><br></pre></td></tr></table></figure></div><p>請求端的程式碼：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var temp &#x3D; &quot;in F12&quot;; &#x2F;&#x2F; 先創立一個測試用的物件，默認值為 in F12</span><br><span class="line">function LucasCallBack(res) &#123; console.log(&quot;CallBackData &#x3D; &quot; + res) &#125; &#x2F;&#x2F; 在LucasTest.js紀載他會呼叫一個函數叫做LucasCallBack，所以我們在本域新增這函數</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &quot;get&quot;, &#x2F;&#x2F; 發起請求方式為Get (詳情請看xhr有支援哪幾種方式)</span><br><span class="line">    async: false, &#x2F;&#x2F; async設定false會變成同步請求 要完成ajax後才會繼續執行 (同樣於xhr標準)</span><br><span class="line">    url: &quot;http:&#x2F;&#x2F;127.0.0.1:5022&#x2F;src&#x2F;LucasTest.js&quot;,</span><br><span class="line">    dataType: &quot;jsonp&quot;, &#x2F;&#x2F; 當接收到跨域資料後，這個資料格式應該為JSONP格式，如果不符合該格式就算本域拿到也會跳到Error函數</span><br><span class="line">    jsonpCallback: &quot;LucasCallBack&quot;, &#x2F;&#x2F; JSONP 拿到後要呼叫的函數，這個函數名稱應該要和LucasTest.js一模一樣</span><br><span class="line">    success: function (res) &#123; &#x2F;&#x2F; 如果判斷拿到的資料符合我們設定的dataType，就會傳送到這邊        </span><br><span class="line">        console.log(&quot;sucess &#x3D; &quot; + res); &#x2F;&#x2F; log出拿到的資料</span><br><span class="line">        alert(&quot;sucess&quot;); &#x2F;&#x2F; 提式成功的字眼在畫面上</span><br><span class="line">        console.log(&quot;temp &#x3D; &quot; + temp); &#x2F;&#x2F; 檢查temp有沒有被修改成功</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function (XMLHttpRequest, textStatus) &#123; &#x2F;&#x2F; 當接收失敗或是檢查dataType失敗，就會傳送到這邊</span><br><span class="line">        alert(&quot;error status &#x3D; &quot; + XMLHttpRequest.status + &quot; , readyState &#x3D; &quot; + XMLHttpRequest.readyState + &quot; , error type &#x3D; &quot; +textStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/rr0UUtX.png" src="/img/loading.gif" class="lazyload" title></a></p><p>由上圖可以看出JSONP的功能，簡單說就是跨域拿到資料後自動使用eval(資料)，如果只需要拿到資料但是不用自動執行，那就用普通的AJAX請求就可以了</p><p>被請求的東西： LucasTest.js</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;我愛張學友&quot;</span><br></pre></td></tr></table></figure></div><p>請求端的程式碼：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var temp &#x3D; &quot;in F12&quot;; &#x2F;&#x2F; 先創立一個測試用的物件，默認值為 in F12</span><br><span class="line">&#x2F;&#x2F; function LucasCallBack(res) &#123; console.log(&quot;CallBackData &#x3D; &quot; + res) &#125; 今天既然不要自動執行，自動執行的函數也沒必要存在</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &quot;get&quot;, &#x2F;&#x2F; 發起請求方式為Get (詳情請看xhr有支援哪幾種方式)</span><br><span class="line">    async: false, &#x2F;&#x2F; async設定false會變成同步請求 要完成ajax後才會繼續執行 (同樣於xhr標準)</span><br><span class="line">    url: &quot;http:&#x2F;&#x2F;127.0.0.1:5022&#x2F;src&#x2F;LucasTest.js&quot;,</span><br><span class="line">    dataType: &quot;text&quot;, &#x2F;&#x2F; 當接收到跨域資料後，這個資料格式應該為JSONP格式，如果不符合該格式就算本域拿到也會跳到Error函數</span><br><span class="line">    &#x2F;&#x2F; textCallback: &quot;LucasCallBack&quot;, 今天既然不要自動執行，自動執行的函數也沒必要存在</span><br><span class="line">    success: function (res) &#123; &#x2F;&#x2F; 如果判斷拿到的資料符合我們設定的dataType，就會傳送到這邊        </span><br><span class="line">        console.log(&quot;sucess &#x3D; &quot; + res); &#x2F;&#x2F; log出拿到的資料</span><br><span class="line">        alert(&quot;sucess&quot;); &#x2F;&#x2F; 提式成功的字眼在畫面上</span><br><span class="line">        console.log(&quot;temp &#x3D; &quot; + temp); &#x2F;&#x2F; 檢查temp有沒有被修改成功</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function (XMLHttpRequest, textStatus) &#123; &#x2F;&#x2F; 當接收失敗或是檢查dataType失敗，就會傳送到這邊</span><br><span class="line">        alert(&quot;error status &#x3D; &quot; + XMLHttpRequest.status + &quot; , readyState &#x3D; &quot; + XMLHttpRequest.readyState + &quot; , error type &#x3D; &quot; +textStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/ofW7JJZ.png" src="/img/loading.gif" class="lazyload" title></a></p><p>以上提供了三種解決跨域問題，但是於安全性規範還是無法拿到Cookie敏感資料。</p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> W3C </tag>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
            <tag> AJAX </tag>
            
            <tag> XMLHttpRequest </tag>
            
            <tag> 跨域 </tag>
            
            <tag> 緩存 </tag>
            
            <tag> CORS </tag>
            
            <tag> Proxy </tag>
            
            <tag> JSONP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.04 - JIT &amp; V8</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.04%20-%20JIT%20&amp;%20V8/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.04%20-%20JIT%20&amp;%20V8/</url>
      
        <content type="html"><![CDATA[<p>承接P.03，JavaScript的其中一個缺陷由JIT去彌補。</p><h1 id="即時編譯：JIT-Just-in-time-compilation-amp-V8："><a href="#即時編譯：JIT-Just-in-time-compilation-amp-V8：" class="headerlink" title="即時編譯：JIT(Just-in-time compilation) &amp; V8："></a>即時編譯：JIT(Just-in-time compilation) &amp; V8：</h1><p>今天JavaScript如何在瀏覽器上工作的，在電影「降臨」外星人降臨地球了，人們為了理解外星人為何降臨於是雙方進行了溝通，但是很明顯外星人聽不懂我們的話，於是有了翻譯的存在，情況像是下面：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/6slRuv5.png" src="/img/loading.gif" class="lazyload" title></a><br>而解釋型就是執行一行翻譯一行，給你看：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/Z34RZTN.png" src="/img/loading.gif" class="lazyload" title></a><br>而編譯型就是全部翻譯完，給你看：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/wcW3Qc5.png" src="/img/loading.gif" class="lazyload" title></a><br>而解釋型對於頻繁執行的重複代碼有缺陷，還是會重新解釋一次，所以JIT就是解決這問題</p><p>JIT這個單字其實不是JavaScript專有 C#、Java、Python等等也皆有使用JIT，但最早使用的是在20世紀Toyota汽車工業中提出生產管理的方法學：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在20世紀後半期，整個汽車市場進入了一個市場需求多樣化的新階段，而且對質量的要求也越來越高，隨之給製造業提出的新課題即是，如何有效地組織多品種小批量生產，否則的話，生產過剩所引起的只是設備、人員、非必須費用等一系列的浪費，從而影響到企業的競爭能力以至生存。</span><br></pre></td></tr></table></figure></div><p>由上述例子可以看到他們提出當時遇到的問題，以此為基礎提出了解決方法就是減少庫存進而減少儲存費用，「讓正確的物資，在正確的時間，流動到正確的地方，數量是剛剛好的數量。」。</p><p>那麼程式語言對於當前解釋器遇到的問題引用該概念，「重複解釋相同指令」就是庫存。</p><p>JIT是混合了編譯器和解釋器這二者，一字一句編譯成原始碼，但是能夠將編譯過的代碼快取儲存以降低效能損耗(下面會詳細介紹)。相對於編譯型，JIT的代碼可以處理延遲繫結並增強安全性。</p><p>那麼這樣新型態的JavaScript是如何實現在瀏覽器的呢？</p><p>今天我們寫的JS程式碼，寄宿在HTML網頁並丟到瀏覽器執行顯示，此時瀏覽器就會有專門處理JavaScript指令碼的虛擬機器，這種東西我們稱之為「JavaScript引擎」。<br>在2008年以前JavaScript引擎一直被當作一門解釋器，用於將JavaScript轉換成各種CPU能夠識別的組語檔(CPU會有各種架構，每種架構都有對應自己的組合語言，而不論編譯還是解釋都會轉成組語檔)。<br>而2008年時Google提出了鼎鼎大名的V8引擎<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/mY8OZZZ.png" src="/img/loading.gif" class="lazyload" title></a></p><p>V8的工作可不是單純的解釋器，它還要負責執行代碼、分配內存、垃圾回收、JIT等等各種技術來優化JavaScript。所以我們知道V8使用各種技術來優化JavaScript解釋器的缺陷，這邊我們舉個範例：</p><p>即時編譯新增了一個監視器，這個監視器監視著程式碼的運行情況，記錄該行程式碼一共運行了多少次，如何運行的等信息。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/9n4XnL7.png" src="/img/loading.gif" class="lazyload" title></a><br>當某一行程式碼被執行多次，監視器就會給予一個標籤 warm，JIT就會把這段代碼的編譯結果儲存下來。<br>當某一行程式碼被執行很多次，監視器就會給予一個標籤 hot，JIT就會把這段代碼的編譯結果進行優化。</p><p>當下次又執行到該行發現是warm為已經解釋過的程式碼時候，JIT就會把結果丟出來給你，並且說：不要再解釋了，上次解釋過了，結果長這樣。<br>當下次又執行到該行發現是hot為已經解釋過並且優化的程式碼時候，JIT就會把結果丟出來給你，並且說：不要再解釋了，上次解釋過了，結果長這樣。</p><p>其優化手段如下：</p><p>未優化的程式碼：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Calculator &#123;</span><br><span class="line">    Wrapper wrapper;</span><br><span class="line">    public void calculate() &#123;</span><br><span class="line">        y &#x3D; wrapper.get();</span><br><span class="line">        z &#x3D; wrapper.get();</span><br><span class="line">        sum &#x3D; y + z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Wrapper &#123;</span><br><span class="line">    final int value;</span><br><span class="line">    final int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>針對 Class Calculator 進行第一步優化會變成：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Calculator &#123;</span><br><span class="line">    Wrapper wrapper;</span><br><span class="line">    public void calculate() &#123;</span><br><span class="line">        y &#x3D; wrapper.value; &#x2F;&#x2F; 此處直接用屬性獲取，不透過函數呼叫減少延遲</span><br><span class="line">        z &#x3D; wrapper.value; &#x2F;&#x2F; 術語稱為 Inlining 為 程式碼注入</span><br><span class="line">        sum &#x3D; y + z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>針對 Class Calculator 進行第二步優化會變成：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Calculator &#123;</span><br><span class="line">    Wrapper wrapper;</span><br><span class="line">    public void calculate() &#123;</span><br><span class="line">        y &#x3D; wrapper.value; &#x2F;&#x2F; 根據 「因為解釋型關係篇」 的文章可以知道，用區域變數存取會減少延遲</span><br><span class="line">        z &#x3D; y;</span><br><span class="line">        sum &#x3D; y + z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>針對 Class Calculator 進行第三步優化會變成：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Calculator &#123;</span><br><span class="line">    Wrapper wrapper;</span><br><span class="line">    public void calculate() &#123;</span><br><span class="line">        y &#x3D; wrapper.value; </span><br><span class="line">        y &#x3D; y; &#x2F;&#x2F; 用 y &#x3D; y 取代 z &#x3D; y， 沒有必要再用一個變數 z，因為 z 跟 y 會是相等的。</span><br><span class="line">        sum &#x3D; y + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>針對 Class Calculator 進行第四步優化會變成：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Calculator &#123;</span><br><span class="line">    Wrapper wrapper;</span><br><span class="line">    public void calculate() &#123;</span><br><span class="line">        y &#x3D; wrapper.value; </span><br><span class="line">        sum &#x3D; y + y; &#x2F;&#x2F; 根據第三步 優化成這樣之後發現 y &#x3D; y 是多餘的程式碼，於是進行剃除就長這樣。 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="runtime："><a href="#runtime：" class="headerlink" title="runtime："></a>runtime：</h1><p>JavaScript的runtime是在腳本化語言定義中所提到的「已存在的實體或系統」。程式碼通過 JavaScript 引擎傳遞，一旦被解析和被理解之後，實體或系統將會執行解釋行為。<br>而對於Client端 這個存在的實體就是瀏覽器，不同瀏覽器提供各自的引擎來解析，告訴瀏覽器要執行對應的行為。然而對於Server開發者就是NodeJS了(後續會介紹)。</p><p>簡單說：JavaScript引擎、虛擬機、runtime  大部分時候三者是通用的，你可以把它當作JavaScript實作的環境，但詳細區別可以看：<a href="https://www.zhihu.com/question/39499036" target="_blank" rel="noopener">https://www.zhihu.com/question/39499036</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JIT </tag>
            
            <tag> V8 </tag>
            
            <tag> 解釋型 </tag>
            
            <tag> Google </tag>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.02 - ECMA、腳本語言</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.02%20-%20ECMA%E7%B5%84%E7%B9%94/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.02%20-%20ECMA%E7%B5%84%E7%B9%94/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h1><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/sC6usCg.png" src="/img/loading.gif" class="lazyload" title></a><br>JavaScript是一門解釋型弱型別的程式語言，由ECMAScript規範的實現，所謂的解釋型請參考「程式語言的誕生」，這邊就不詳細討論(後面會簡單介紹)，讓我們先暫停在這。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/KoC0wnI.jpg" src="/img/loading.gif" class="lazyload" title></a></p><h2 id="什麼是-ECMAScript？"><a href="#什麼是-ECMAScript？" class="headerlink" title="什麼是 ECMAScript？"></a>什麼是 ECMAScript？</h2><p>ECMAScript是由ECMA組織制定的腳本語言規範，代號為TC39，你可以把它當作是一個腳本語言的規格書，這個規範紀載了</p><ol><li>腳本語言應該要有個關鍵字，只要被他賦予的變數，就無法修改了</li><li>腳本語言應該要有個能夠異步操作的關鍵字</li><li>腳本語言應該要有個更簡易的製作函數的寫法</li></ol><p>在 ECMAScript 制定完成這些後，他們做了什麼？答案是：「ECMA 他們什麼都不幹」。於是就有了JavaScript 這語言把ECMAScript實做出來：</p><ol><li>const temp = 20; </li><li>new Promise( Fun:Function)</li><li>var Fun = ()=&gt; {}; </li></ol><p>JavaScript根據規範制定了上述的3點。</p><p>而ECMA他們甚至想要定義時間的作用，應該也考慮進火星的時間，因為JavaScript被廣泛使用，甚至連NASA的太空服軟件也是JavaScript寫的。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/xyi9Z9I.png" src="/img/loading.gif" class="lazyload" title></a></p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/TWXAGxd.png" src="/img/loading.gif" class="lazyload" title></a></p><p>由上大概可以知道 ECMAScript 創立了 JavaScript ，但其實不盡然，在我還沒出生時那時第一次瀏覽器大戰已經開打，微軟 - IE VS 網景 - Netscape。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/Ctzj7us.png" src="/img/loading.gif" class="lazyload" title></a><br>在這場戰爭中還沒有標準化的概念，所以你用你的我用我的，造成很多網頁上寫明：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">「用IE可達到最佳效果」</span><br><span class="line">「用Netscape可達到最佳效果」</span><br></pre></td></tr></table></figure></div><p>在大戰中網景公司認為網頁需要一種腳本語言，讓網頁設計師可以很容易地使用它來組裝圖片和外掛程式之類的元件，且程式碼可以直接編寫在網頁標記中。於是JavaScript因此而誕生。</p><p>而之所以取名”Java”Script只是因為當時Java很夯，沾點熱度而已，本質跟Java沒有任何關係。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/jJvCXUX.png" src="/img/loading.gif" class="lazyload" title></a></p><p>網景一推出大受好評，微軟也跟進自己設計了JScript，但也因此 你用你的、我用我的 這情況更嚴重，於是網景向ECMA提出標準，ECMA根據JavaScript制定了ECMAScript規範，當然ECMA會採用JScript和JavaScript的相容。</p><h2 id="什麼是腳本語言？"><a href="#什麼是腳本語言？" class="headerlink" title="什麼是腳本語言？"></a>什麼是腳本語言？</h2><p>假設我們要 “走” 、 “跑” 、 “跳” 等等，這些動作在程式碼中都可以被定義為一個命令或是函數，然而這些操作必須由某個東西來驅動，像是如果沒有人，何來的 “走” 、 “跑” 、 “跳” ？ 這專注於操縱外部實體的語言稱為腳本語言或是膠水語言。</p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端歷史 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ECMA </tag>
            
            <tag> ECMAScript </tag>
            
            <tag> 第一次瀏覽器大戰 </tag>
            
            <tag> IE </tag>
            
            <tag> Netscape </tag>
            
            <tag> 腳本語言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.03 - 分析解釋型、弱型別</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.03%20-%20%E5%88%86%E6%9E%90%E8%A7%A3%E9%87%8B%E5%9E%8B%E3%80%81%E5%BC%B1%E5%9E%8B%E5%88%A5/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.03%20-%20%E5%88%86%E6%9E%90%E8%A7%A3%E9%87%8B%E5%9E%8B%E3%80%81%E5%BC%B1%E5%9E%8B%E5%88%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="為什麼是解釋型？"><a href="#為什麼是解釋型？" class="headerlink" title="為什麼是解釋型？"></a>為什麼是解釋型？</h1><p>首先電腦只能看懂「機器語言」(詳情請看「程式語言的誕生」)，所有程式語言都可以分為兩類，編譯型、解釋型。這邊不詳細敘述編譯型和解釋型的流程(詳情請看「程式語言的誕生」)，此處就用粗略的比喻來解釋：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">今天你是個導演，你寫了劇本，找了演員</span><br><span class="line"></span><br><span class="line">編譯型：演員要花1小時背下來，思考1小時演藝技巧，然後開始演出</span><br><span class="line">解釋型：演員先花2分鐘被一段台詞，思考2分鐘，然後開始演出一小段後演員說：導演暫停一下，我繼續背下一段，2分鐘就好 ... etc。</span><br></pre></td></tr></table></figure></div><p>從上述結果來看編譯型應該是比較好的結果，但是如果今天劇組都找好了，你是演員會是如何處理呢：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">編譯型：導演等等，我要花1小時背台詞，就算你現在全劇組準備好，你還是要等我背1小時。</span><br><span class="line">解釋型：導演等等，我要花2分鐘背一小段台詞，就算你現在全劇組準備好，你還是要等我背2分鐘。</span><br></pre></td></tr></table></figure></div><p>這樣看起來好像又是解釋型好一點。假設今天你的瀏覽器就是劇組，如果你要看一個網頁的話，你是想要等1小時後才能看到結果還是等2分鐘先看第一個頁面呢？答案昭然若揭。於是JavaScript就成為了解釋型語言，也更符合網頁的特色需求。</p><h1 id="什麼是弱型別？"><a href="#什麼是弱型別？" class="headerlink" title="什麼是弱型別？"></a>什麼是弱型別？</h1><p>就是宣告變數時候不用給予資料型別，像是宣告變數a，你不用跟電腦說他是String還是Int。但是如果發生資料型別不符合的話，就會自動進行轉化強行執行。</p><p>強型別：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 20;</span><br><span class="line">string b &#x3D; &quot;40&quot;;</span><br><span class="line">int sum &#x3D; a + Convert.toInt32(a+b); &#x2F;&#x2F; 一定要轉換不然編譯不了，其結果為 60</span><br></pre></td></tr></table></figure></div><p>弱型別：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 20;</span><br><span class="line">var b &#x3D; &quot;40&quot;;</span><br><span class="line">var sum &#x3D; a + b &#x2F;&#x2F; 2040 此時sum為字串</span><br></pre></td></tr></table></figure></div><h1 id="那弱型別和解釋型有什麼壞處？"><a href="#那弱型別和解釋型有什麼壞處？" class="headerlink" title="那弱型別和解釋型有什麼壞處？"></a>那弱型別和解釋型有什麼壞處？</h1><ol><li>開發和維護不容易、不易於大型專案</li><li>Debug困難</li><li>效能問題</li></ol><p>針對這3點詳細展開來看</p><ol><li><p>因為它是弱型別所以可能某個變數在第10行還是int，經過一輪番操作，第1000行這個變數變成了string，並且這操作屬於合法操作，所以維護和Debug困難導致不適合大型專案，當然這還是跟開發者素質有關，素質好的開發者不會有這問題。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var temp &#x3D; &quot;50&quot;</span><br><span class="line">...... &#x2F;&#x2F; 經過一系列的操作</span><br><span class="line">console.log(type of (temp)) &#x2F;&#x2F; temp變成了 int</span><br></pre></td></tr></table></figure></div></li><li><p>因為弱型別關係：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/pmE8DYk.png" src="/img/loading.gif" class="lazyload" title></a><br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/T1jGJQv.png" src="/img/loading.gif" class="lazyload" title></a></p></li><li><p>因為解釋型關係：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/Uy4mnj2.png" src="/img/loading.gif" class="lazyload" title></a></p></li><li><p>因為解釋型關係：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hello&quot;)</span><br><span class="line">console.log(&quot;Hello&quot;)</span><br><span class="line">console.log(&quot;Hello&quot;)</span><br><span class="line">console.log(&quot;Hello&quot;)</span><br><span class="line">console.log(&quot;Hello&quot;)</span><br><span class="line">console.log(&quot;Hello&quot;)</span><br><span class="line">....</span><br></pre></td></tr></table></figure></div><p>上述程式碼，就只是一直輸出Hello，但其中一樣的程式碼我已經解釋過一次了，可是我是解釋器的關係還是重新解釋，這不就是效能低下的表現嗎？</p></li></ol><p>綜上所述，可以知道JavaScript的設計對於效能很難有提高，因為語言本身缺陷，容易導致開發者寫出素質不好的程式碼。於是就有些專家提出一些解決方案：</p><ol><li>解釋型的問題，使用了JIT技術來優化，JIT的優化讓Javascript大大提升，如圖中所示：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/yNWTLdC.png" src="/img/loading.gif" class="lazyload" title></a></li><li>弱型別的問題，微軟提出一個TypeScript的程式語言，該程式語言能夠支援JavaScript並且給予強型別的檢查效果。</li><li>JIT和TypeScript的問題，這兩者都是基於JavaScript開發出來的產品，雖然使用它們可以有效降低，但還是有一些效能本質問題，於是Mozilla、Google、Microsoft、Apple這四大瀏覽器開發商一起推出了瀏覽器能夠識別的第四種程式語言：WebAssembly</li></ol><p>以上三種解決方案，請看下回分析。</p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JIT </tag>
            
            <tag> 解釋型 </tag>
            
            <tag> 弱型別 </tag>
            
            <tag> TypeScript </tag>
            
            <tag> WebAssembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.05 - TypeScript</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.05%20-%20TypeScript/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.05%20-%20TypeScript/</url>
      
        <content type="html"><![CDATA[<p>承接P.03，JavaScript的其中一個缺陷由TypeScript去彌補。</p><h1 id="TypeScript："><a href="#TypeScript：" class="headerlink" title="TypeScript："></a>TypeScript：</h1><p>首先沒有瀏覽器能夠識別TypeScript語言，這很重要的概念所以必須先提出來。<br>TypeScript這是一種JavaScript的嚴格超集語言，為的就是要解決弱型別的問題，他新增了強型別功能，你可以在宣告變數時候新增強型別寫法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var temp:number &#x3D; 20; &#x2F;&#x2F; 賦予型別</span><br><span class="line">temp &#x3D; &quot;hello&quot; &#x2F;&#x2F; 因為型別不對，會失敗</span><br></pre></td></tr></table></figure></div><p>以上就是TypeScript的寫法，可以透過TypeScript編譯器把這段轉換成JavaScript，之後在丟給瀏覽器識別，而今天這Case編譯器會發現你型別錯誤，所以會報錯讓你知道你犯了弱型別的問題。<br>TypeScript就是由此來解決弱型別的問題，但是TypeScript是JavaScript的超集，所以你可以用純JavaScript的方式開發，像是以下寫法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var temp &#x3D; 20;</span><br><span class="line">temp &#x3D; &quot;hello&quot;</span><br></pre></td></tr></table></figure></div><p>你寫這段程式碼把他丟給TypeScript編譯器，編譯器不會抱錯，因為TypeScript是JavaScipt的超集，任何的JavaScript程式碼，在TypeScript都是合法的語言。</p><h2 id="編譯器："><a href="#編譯器：" class="headerlink" title="編譯器："></a>編譯器：</h2><p>TypeScipt編譯器，以下簡稱為tsc，所以由上述可以知道，tsc是構成TypeScript的關鍵核心，今天就算我寫了符合TypeScript的語法，但是沒編譯器幫助還是沒有瀏覽器能看懂，所以我們來介紹編譯器。<br>首先呢tsc是開源的，微軟tsc GitHub：<a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript</a><br>而根據TypeScript官網的使用說明，我們可以知道tsc會吃一個配置文件，這個文件叫做tsconfig.json。這個配置文件紀載了很多編譯條件，我們可以透過新增一些編譯條件來控管編譯嚴格程度，以此達到控管CodeStyle。</p><p>而基本tsconfig.json大概長這樣：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">        &quot;outDir&quot;: &quot;bin-debug&quot;,</span><br><span class="line">        &quot;removeComments&quot;: true,</span><br><span class="line">        &quot;experimentalDecorators&quot;: true,</span><br><span class="line">        &quot;lib&quot;: [</span><br><span class="line">            &quot;es5&quot;,</span><br><span class="line">            &quot;dom&quot;,</span><br><span class="line">            &quot;es2015.iterable&quot;,</span><br><span class="line">            &quot;es2015.promise&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;types&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;include&quot;: [</span><br><span class="line">        &quot;src&quot;,</span><br><span class="line">        &quot;libs&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>target：編譯出來的JavaScript是什麼版本(版本問題後續會講，這是個大坑)<br>outDir：編譯出來的JavaScript檔案要放在哪個資料夾<br>lib：撰寫的TypeScript使用了什麼JavaScript API(後續會講)<br>include：我要編譯的TypeScript檔案有哪些(資料夾或是指定XXXX.ts都可以)</p><p>首先呢compilerOptions裡面可以新增一些編譯條件，來控管CodeStyle，這邊舉例一些好用的編譯條件，其他有什麼編譯條件可以參考：<a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/compiler-options.html</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;strictNullChecks&quot;: true, &#x2F;&#x2F; 啟用嚴格的 null 檢查</span><br><span class="line">&quot;noUnusedLocals&quot;: true, &#x2F;&#x2F; 有未使用的變量時，拋出錯誤</span><br><span class="line">&quot;noUnusedParameters&quot;: true, &#x2F;&#x2F; 有未使用的參數時，拋出錯誤</span><br><span class="line">&quot;noImplicitReturns&quot;: true &#x2F;&#x2F; 並不是所有函數里的代碼都有返回值時，拋出錯誤</span><br></pre></td></tr></table></figure></div><p>以上，就是呼叫tsc時候可以加選的項目。 至於如何使用tsc請參考後面的教學「如何使用工具」篇</p><h1 id="版本問題："><a href="#版本問題：" class="headerlink" title="版本問題："></a>版本問題：</h1><p>由於ECMAScript一直改版，每次改版就會有新的API或是新的語法，但是開發瀏覽器JavaScript引擎的四大廠商：Edge(微軟)、Chrome(Google)、FireFox(Mozilla)、Safari(蘋果)。他們卻未能馬上更新，畢竟頻繁改版會造成穩定性和安全性的隱患。所以就算現在出到ES10，但也沒有任何一個瀏覽器能支援到ES10的版本。</p><p>更何況不是每個人都會更新，像是現在還有人用IE，根據使用者習慣不同，有些人使用的瀏覽器還不是上述四大廠商，像是中國就有很多瀏覽器：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/V8rQkVB.png" src="/img/loading.gif" class="lazyload" title></a><br>這就會導致今天我撰寫的JavaScript版本是ES6，但是你用的瀏覽器太舊了，無法識別ES6的語法或是API就無法執行，各瀏覽器能支援的版本請參考以下網站：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/IUo43r1.png" src="/img/loading.gif" class="lazyload" title></a></p><p><a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">https://kangax.github.io/compat-table/es6/</a><br><a href="https://caniuse.com/" target="_blank" rel="noopener">https://caniuse.com/</a></p><h1 id="如何使用JavaScript的API："><a href="#如何使用JavaScript的API：" class="headerlink" title="如何使用JavaScript的API："></a>如何使用JavaScript的API：</h1><p>這邊的JavaScriptAPI不只是官方API，還包含了其他人寫的JavaScript的函示庫。<br>因為JavaScript橫行了很多年，很多人為了他寫了一些知名的API，最近幾年TypeScript才開始問世，然而從JavaScript轉換成純TypeScript是有段陣痛期的。所以很多人還是不願意使用TypeScript方式開發，畢竟只要你有良好CodeStyle，就不會犯了JavaScript的缺陷了。<br>但是對於我們TypeScript開發者來說不是很友善，因為一些知名大老寫的庫都是JavaScript，如果我直接呼叫會發生什麼情況：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大老用JavaScript寫的程式碼，檔案名稱叫做 大老.js：</span><br><span class="line">function SayHello(msg) &#123; console.log(msg) return msg + &quot;你好&quot;&#125;;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我自己在TypeScript寫的程式碼，檔案名稱叫做 Lucas.ts：</span><br><span class="line">var Response:string &#x3D; SayHello(&quot;Lucas&quot;);</span><br></pre></td></tr></table></figure></div><p>這樣我直接把自己的TypeScript程式碼送去tsc處理，就會報錯說：找不到SayHello函數。<br>為什麼會發生這問題？因為tsc只負責編譯ts檔案，而你使用的API根本沒有導入到ts文件裡面，所以他才找不到，那怎麼解決呢？</p><ol><li>把大佬的JavaScript移植到TypeScript裡面，是其中一個方法，但是這樣就代表你要改寫大老的程式碼，你要如何確認這個型態是什麼？修改後有可能不會有Bug？</li><li>那我根據TypeScript是JavaScript的超集這關係，我直接把大老的純JavaScript 貼在TypeScript內也不會有問題吧，的確不會有問題，但是純JavaScript沒有型別提示，你最後必定是用any型態去接大老回傳的東西，這不就違背了初心了嗎，當初你選擇TypeScript就是為了不要寫出弱型態的缺陷問題，但是今天你還是用弱型別方式去接收大老的資料，莫忘初心!!!。</li></ol><p>那麼我該如何處理？<br>你應該使用最TypeScript的方式去處理這問題，你必須推測這個JavaScript的函數會回傳什麼資料型別，然後自己寫一個interface去建立一個於TypeScript抽象未實做的同名函數，而這種檔案通常都會跟源JS取名差不多，假設源JS叫做 大老.js ，你要寫一個抽象函數 那這隻抽象TypeScript檔案就必須叫做 大老.d.ts。所以以後看到.d.ts類型的檔案就知道，這些interface適用於處理TypeScript與JavaScipt溝通的橋樑。</p><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/yShkQoS.png" src="/img/loading.gif" class="lazyload" title></a></p><p>使用程式語言的抽象概念，騙過我們的tsc編譯器。抽象概念不是由TypeScript研發出來的，只要是強型別語言都會有抽象語法，所以不懂的人請自行google。</p><h1 id="開發工具："><a href="#開發工具：" class="headerlink" title="開發工具："></a>開發工具：</h1><p>有些人畫圖喜歡用小畫家，有些人喜歡用Photoshop，兩者都能夠畫圖，只是效率問題。而根據上述的Case，你必須寫好TS程式碼後送去tsc處理才能知道自己有沒有寫錯，這不是很笨嗎，如果我能夠在寫的瞬間就知道這寫法是錯誤的不就聰明點，像是圖中範例：<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/3AHouYT.png" src="/img/loading.gif" class="lazyload" title></a><br>於是就微軟公司開發了 VSCode 工具。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/bWhKNgu.png" src="/img/loading.gif" class="lazyload" title></a></p><p>VSCode，也是一種程式開發工具，他整合了很多功能、開放擴充工具等等。由於是微軟開發的工具，對微軟自家的程式語言TypeScript具有非常友善的特性，特性之一你能夠在撰寫的瞬間就知道這寫法是否有問題，你可以當作VSCode裡面有套tsc，能夠隨時檢查你的語法，不至於寫完後丟給tsc才知道自己寫錯了。</p><p>那麼我安裝了VSCode就不用下載tsc了，因為VSCode裡面就有內建tsc隨時檢查我的語法？答案：No。首先JavaScript一直改版，就會導致TypeScript也跟著改版，更何況誰說TypeScript編譯器不會有Bug，所以你無法直接使用VSCode裡面的編譯器(嚴格說他也沒有編譯器在裡面。)，誰知道你在2010安裝後就一直沒有更新VSCode。所以你還是必須下載最新版本的tsc，更何況還有以下問題。</p><p>假設今天我是用了JavaScript ES5官方API，根據「如何使用JavaScript的API」可以知道，我之所以能夠呼叫是因為有.d.ts的存在，對於官方API也是如此，對於tsc來說.d.ts放置於 <a href="https://github.com/microsoft/TypeScript/tree/master/lib" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/tree/master/lib</a></p><p>而對於VSCode來說，為了要實現即時報錯的功能，所以必須自己也有一份.d.ts。<br>其位置：C:\Users\使用者\AppData\Local\Programs\Microsoft VS Code\resources\app\extensions\node_modules\typescript\lib<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/cupwbKJ.png" src="/img/loading.gif" class="lazyload" title></a></p><p>以此為標準進行檢查你當前輸入的東西和.d.ts是否相符合，不符合就進行紅字警告。但是我們去造訪此資料夾可以發現，裡面最高版本的.d.ts是2017，也就是俗稱的ES 8。而tsc裡面已經支援到es2020了，很明顯VSCode的即時報錯功能在es8以上會失效，所以要處理這問題的話，我就必須把tsc的lib和VSCode的lib進行同步或是重新安裝最新版VSCode。</p><h6 id="當然失效的就只是VSCode的即時報錯，但對於tsc來說這東西還是合法的，不會有問題，還是可以順利轉換成JavaScript"><a href="#當然失效的就只是VSCode的即時報錯，但對於tsc來說這東西還是合法的，不會有問題，還是可以順利轉換成JavaScript" class="headerlink" title="當然失效的就只是VSCode的即時報錯，但對於tsc來說這東西還是合法的，不會有問題，還是可以順利轉換成JavaScript"></a>當然失效的就只是VSCode的即時報錯，但對於tsc來說這東西還是合法的，不會有問題，還是可以順利轉換成JavaScript</h6><h6 id="我安裝VSCode的時間很久了，這是在好幾年前安裝的必定不會有ES2020這鬼東西，而且我也沒主動去重新更新。"><a href="#我安裝VSCode的時間很久了，這是在好幾年前安裝的必定不會有ES2020這鬼東西，而且我也沒主動去重新更新。" class="headerlink" title="我安裝VSCode的時間很久了，這是在好幾年前安裝的必定不會有ES2020這鬼東西，而且我也沒主動去重新更新。"></a>我安裝VSCode的時間很久了，這是在好幾年前安裝的必定不會有ES2020這鬼東西，而且我也沒主動去重新更新。</h6>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 弱型別 </tag>
            
            <tag> TypeScript </tag>
            
            <tag> 強型別 </tag>
            
            <tag> tsconfig.json </tag>
            
            <tag> tsc </tag>
            
            <tag> CodeStyle </tag>
            
            <tag> 抽象檔案.d.ts </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端P.01 - 網頁三兄弟</title>
      <link href="/2021/04/02/%E5%89%8D%E7%AB%AFP.01%20-%20%E7%B6%B2%E9%A0%81%E4%B8%89%E5%85%84%E5%BC%9F/"/>
      <url>/2021/04/02/%E5%89%8D%E7%AB%AFP.01%20-%20%E7%B6%B2%E9%A0%81%E4%B8%89%E5%85%84%E5%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>前端工程師，前端工作是什麼？<br>前端的工作用最粗略和簡單的說法就是，假設今天你想要把你的照片丟在網頁上給別人看，那麼要怎麼丟，要怎麼呈現，這就是前端的工作。</p><p>首先你要看網頁，你就必須要有瀏覽器，主流瀏覽器：Edge(微軟)、Chrome(Google)、FireFox(Mozilla)、Safari(蘋果)<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/S8z19lm.png" src="/img/loading.gif" class="lazyload" title></a></p><p>而網頁需要用瀏覽器去觀看，就像是吃東西必須由嘴巴來咀嚼，而不是所有東西都能咀嚼，像是鋼鐵你能吃嗎？所以對於瀏覽器來說也是如此，當前瀏覽器只能識別三種程式語言所開發的產品：Html、Javascript、CSS。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/1Yb84KH.png" src="/img/loading.gif" class="lazyload" title></a><br>由上圖可以知道這三者都有負責不同的業務：</p><ul><li>Html負責把網頁的結構生出來，像是這邊需要一個按鈕之類的架構。</li><li>CSS負責美化，讓網頁看起來漂亮一點。</li><li>JavaScript負責控制交互邏輯、行為，像是按下按鈕後應該跑出什麼東西之類的。</li></ul><p>而這些東西是誰制定的？答案：W3C<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/gM9LDro.png" src="/img/loading.gif" class="lazyload" title></a><br>跟網路通訊一樣，瀏覽器也是依靠一堆協定堆積出來的應用層產品(詳細請看OSI介紹)，而要制定這樣得組織就必須是全球很有話語權的人，這個人就是提姆·柏內茲-李<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/rdSDd3v.png" src="/img/loading.gif" class="lazyload" title></a><br>也就是這個人規定了為什麼網址必須是http:// 為什麼一定要兩個斜線？就是這個人規定的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">柏內茲在接受泰晤士報採訪時，承認網址中的雙斜線（&#x2F;&#x2F;）並非必要。</span><br><span class="line">他還表示，他可以輕易設計出一種無需斜線的URL。柏內茲-李為掉以輕心道歉，並說「這個主意在那時看起來不錯。」。</span><br></pre></td></tr></table></figure></div><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/h7b3BTK.png" src="/img/loading.gif" class="lazyload" title></a></p><p>而隨著時代的演進</p><ul><li>Html也一直在改版，現在改到html 5 版本。</li><li>Javascript也一直在改版，現在改到 ECMAScript 2019 （簡稱ES2019），第 10 版 (簡稱ES10)</li><li>CSS也一直在改版，現在改到CSS2.1</li></ul><p>而很多人以此三大類為基礎開發了延伸產品</p><ul><li>Html延伸出DOM</li><li>JavaScript延伸出NodeJS</li><li>CSS延伸出SASS和LESS</li></ul><p><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/vCxLFMU.png" src="/img/loading.gif" class="lazyload" title></a></p><p>而今天我們介紹的主角就是JavaScript，其他Html和CSS以後會在教學。</p>]]></content>
      
      
      <categories>
          
          <category> 前端系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端歷史 </tag>
            
            <tag> W3C </tag>
            
            <tag> Html </tag>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 瀏覽器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部落格介紹</title>
      <link href="/2020/02/14/%E9%83%A8%E8%90%BD%E6%A0%BC%E4%BB%8B%E7%B4%B9/"/>
      <url>/2020/02/14/%E9%83%A8%E8%90%BD%E6%A0%BC%E4%BB%8B%E7%B4%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>大家好我是Lucas，這個部落格將會是一篇系列文章，主要講述方式會偏向於「面相大眾的教學」，動機由以下幾點：</p><ol><li><p>因為任職過公司內部文化有讀書會、分享會的存在，我們進行互相學習、教學，在這過程中我發現最好的學習方式，就是「教別人」，在準備教學過程我會做很多學習，確保我的知識不會是錯的，並且還會潤稿，這種說法能不能說服我自己，以此更加深記憶。</p></li><li><p>因為我也是個熱衷於學習的人，對於網路上有很多教學文章都似懂非懂，很多只講一半，沒有一套能夠說服我的文章，好就是「X分鐘看電影」系列影片，所以打算系統的整理我的學習成果，並且會讓每個知識都進行連結。</p></li><li><p>學習的心得都會是以「人話」來呈現，對於一些艱澀的專有名詞都會有自己的一套口吻化的解釋，但是難保其中不會有錯誤，所以也打算請大家，如果我有寫錯或是錯誤的觀念等等。懇請賜教，願聞其詳。<br><a href="/img/loading.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://i.imgur.com/04a1PR3.jpg" src="/img/loading.gif" class="lazyload" title></a></p></li></ol><h1 id="先備知識："><a href="#先備知識：" class="headerlink" title="先備知識："></a>先備知識：</h1><p>必須會寫程式，要能夠看懂基本程式碼操作、變數型態是什麼意思、函數寫法。最基本的概念這邊都不會敘述，不一定要會寫JavaScript，但是起碼要會寫程式。</p><h1 id="規劃："><a href="#規劃：" class="headerlink" title="規劃："></a>規劃：</h1><p>基本上會先搭配一些歷史，以此了解為什麼這東西、概念會產生，由最一開始的源頭開始追朔到現在的前端。主要專注於JavaScript，至於Html、CSS則不會詳細敘述，可能後續的Hexo部落格會詳細敘述。</p>]]></content>
      
      
      <categories>
          
          <category> 基本文件 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
